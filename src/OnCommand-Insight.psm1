# workarounds for PowerShell issues
if ($PSVersionTable.PSVersion.Major -lt 6) {
    Add-Type @"
        using System.Net;
        using System.Security.Cryptography.X509Certificates;
        public class TrustAllCertsPolicy : ICertificatePolicy {
           public bool CheckValidationResult(
                ServicePoint srvPoint, X509Certificate certificate,
                WebRequest request, int certificateProblem) {
                return true;
            }
        }
"@

    # OCI 7.2 only supports TLS 1.2 and PowerShell does not auto negotiate it, thus enforcing TLS 1.2 which works for older OCI Versions as well
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

    # Using .NET JSON Serializer as JSON serialization included in Invoke-RestMethod has a length restriction for JSON content
    Add-Type -AssemblyName System.Web.Extensions
    $global:javaScriptSerializer = New-Object System.Web.Script.Serialization.JavaScriptSerializer
    $global:javaScriptSerializer.MaxJsonLength = [System.Int32]::MaxValue
    $global:javaScriptSerializer.RecursionLimit = 99

    
}















<#
    .SYNOPSIS
    Retrieve currently logged in user
    .DESCRIPTION
    Retrieve currently logged in user
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciCurrentUser {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                   Position=0,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/admin/users/current"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }
        
        $User = ParseUsers($Result)
        Write-Output $User
    }
}

# TODO: Implement / Test deletion of user
<#
    .SYNOPSIS
    Delete one user
    .DESCRIPTION
    
    .PARAMETER id
    The id of user to delete
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Remove-OciUser {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="The id of user to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@()
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/admin/users/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                if ('DELETE' -match 'PUT|POST') {
                    Write-Verbose "Body: "
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body "" -ContentType 'application/json'
                }
                else {
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
                }
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one user
    .DESCRIPTION
    Retrieve one user
    .PARAMETER id
    The id of user to retrieve
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciUser {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="The id of user to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/admin/users/$id"
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $User = ParseUsers($Result)
            Write-Output $User
        }
    }
}

# TODO: Implement / Test updating of users
<#
    .SYNOPSIS
    Update one user
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>
{
    "password": "pwd",
    "email": "email@test.com",
    "insightRole": "USER",
    "isActive": false
}
</pre>
            
    .PARAMETER id
    The id of user to update
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Update-OciUser {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="The id of user to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@()
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/admin/users/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                if ('PUT' -match 'PUT|POST') {
                    Write-Verbose "Body: "
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body "" -ContentType 'application/json'
                }
                else {
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers
                }
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all annotation definitions
    .DESCRIPTION
    Retrieve all annotation definitions
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciAnnotations {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/annotations"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }
           
        Write-Output $Result
    }
}

<#
    .SYNOPSIS
    Add annotation
    .DESCRIPTION
    Add annotation
    .PARAMETER name
    Annotation name
    .PARAMETER type
    Annotation type. Must be either DATE, TEXT, FIXED_ENUM, FLEXIBLE_ENUM, BOOLEAN or NUMBER
    .PARAMETER description
    Annotation description
    .PARAMETER enumValues
    List of name, label pairs for enum types (e.g. @(@{name='name',label='label'}) )
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Add-OciAnnotation {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                   Position=1,
                   HelpMessage="Annotation name")][String]$Name,
        [parameter(Mandatory=$True,
                   Position=2,
                   HelpMessage="Annotation type. Must be either DATE, TEXT, FIXED_ENUM, FLEXIBLE_ENUM, BOOLEAN or NUMBER")][ValidateSet("DATE","TEXT","FIXED_ENUM","FLEXIBLE_ENUM","BOOLEAN","NUMBER")][String]$Type,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="Annotation description.")][String]$Description,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="List of name, label pairs for enum types (e.g. @(@{name='name',label='label'}) )")][PSCustomObject[]]$enumValues,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/annotations"
 
            if ($type -match "ENUM" -and -not $enumValues) {
                throw "$type specified, but no enumValues provided"
            }

            try {
                $Body = ConvertTo-Json @{name=$name;type=$type;description=$description;enumValues=$enumValues} -Compress -Depth 4
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

# TODO: Implement / Test deletion of annotation definitions
<#
    .SYNOPSIS
    Delete annotation definition by id or name
    .DESCRIPTION
    Delete annotation definition by id or name
    .PARAMETER id
    Id or name of annotation definition to delete
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Remove-OciAnnotation {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id or name of annotation definition to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/annotations/$id"
 
            try {
                Write-Verbose "Body: "
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body "" -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotation definition
    .DESCRIPTION
    Retrieve annotation definition
    .PARAMETER id
    Id or name of annotation definition to retrieve
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciAnnotation {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id or name of annotation definition to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/annotations/$id"
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Annotation = ParseAnnotations($Result)
            Write-Output $Annotation
        }
    }
}

# TODO: Implement / Test updating of annotations
<#
    .SYNOPSIS
    Update annotation definition by id or name
    .DESCRIPTION
    Request body could include optional name, description, enum values. Enums should contain name and label. Example: <br/>

<pre>
{
    "name": "MyStorageLocation",
    "description": "My Storage Location",
    "enumValues": [
        {
          "name": "PT_LISBON",
          "label": "Lisbon (Portugal)"
        },
        {
          "name": "US_WALTHAM",
          "label": "Waltham (USA)"
        },
        {
          "name": "US_SUNNYVALE",
          "label": "Sunnyvale (USA)"
        }
    ]
}
</pre>
        
    .PARAMETER id
    Id or name of annotation definition to update
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Update-OciAnnotation {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id or name of annotation definition to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/annotations/$id"
 
            try {
                if ('PATCH' -match 'PUT|POST') {
                    Write-Verbose "Body: "
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body "" -ContentType 'application/json'
                }
                else {
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers
                }
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Remove object annotation values in bulk by annotation
    .DESCRIPTION
    Remove object annotation values in bulk by annotation    
    .PARAMETER id
    Id or name of annotation to remove values from
    .PARAMETER objectType
    Object type of objects where annotations should be deleted (e.g. StoragePool or InternalVolume)
    .PARAMETER targets
    IDs of object where annotation should be deleted
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Remove-OciAnnotationValues {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id or name of annotation to remove values from",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Object type of objects where annotations should be deleted (e.g. StoragePool or InternalVolume)")][String]$objectType,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="IDs of object where annotation should be deleted")][PSObject[]]$targets,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/annotations/$id/values"

            if ($targets -and $objectType) {
                $items = @(@{objectType=$objectType;values=@{targets=$targets}})
            }
            else {
                Write-Verbose "Deleting all values from annotation with ID $id"
                $items = Get-OciAnnotationValues -id $id -server $server
            }

            try {
                foreach ($item in $items) {
                    $objectType = $item.objectType
                    $targets = $item.values.targets | % { $_ -split '/' | select -last 1 }
                    if ($targets) {
                        $Body = ConvertTo-Json @(@{objectType=$objectType;targets=$targets}) -Compress -Depth 4
                        Write-Verbose "Body: $Body"
                        $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
                    }
                }
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotation definition values for all supported object types
    .DESCRIPTION
    Retrieve annotation definition values for all supported object types
    .PARAMETER id
    Id or name of annotation definition to retrieve values for
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciAnnotationValues {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id or name of annotation definition to retrieve values for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/annotations/$id/values"
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update object annotations in bulk by annotation
    .DESCRIPTION
    Update object annotations in bulk by annotation     
    .PARAMETER id
    Id or name of annotation definition to update
    .PARAMETER objectType
    Object type of objects where annotations should be added (e.g. StoragePool or InternalVolume)
    .PARAMETER rawValue
    Value of Annotation
    .PARAMETER targets
    IDs of object where annotation should be added
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Update-OciAnnotationValues {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id or name of annotation definition to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Object type of objects where annotations should be added (e.g. StoragePool or InternalVolume)")][String]$objectType,
        [parameter(Mandatory=$True,
                    Position=2,
                    HelpMessage="Value of Annotation")][String]$rawValue,
        [parameter(Mandatory=$True,
                    Position=3,
                    HelpMessage="IDs of object where annotation should be added")][String[]]$targets,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/annotations/$id/values"

            try {
                $Body = ConvertTo-Json @(@{objectType=$objectType;values=@(@{rawValue=$rawValue;targets=$targets})}) -Compress -Depth 4
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotation definition values for one supported object type
    .DESCRIPTION
    'targets' in response contains URLs for target objects
    .PARAMETER id
    Id or name of annotation definition to retrieve
    .PARAMETER objectType
    The object type to retrieve values for
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciAnnotationValuesByObjectType {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id or name of annotation definition to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="The object type to retrieve values for")][String]$objectType,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/annotations/$id/values/$objectType"
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

# TODO: Implement / Test updating of annotation definitions
<#
    .SYNOPSIS
    Retrieve annotation definition targets for one supported object type, one specific value
    .DESCRIPTION
    Returns list of URLs for objects for annotation, object type, value
    .PARAMETER id
    Id or name of annotation definition to retrieve
    .PARAMETER objectType
    The object type to retrieve target objects for
    .PARAMETER value
    The specific value to retrieve target objects for
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Update-OciAnnotationValuesByObjectTypeAndValue {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id or name of annotation definition to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="The object type to retrieve target objects for")][String]$objectType,
        [parameter(Mandatory=$True,
                    Position=2,
                    HelpMessage="The specific value to retrieve target objects for")][String]$value,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@()
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/annotations/$id/values/{objectType}/{value}"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                if ('GET' -match 'PUT|POST') {
                    Write-Verbose "Body: "
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers -Body "" -ContentType 'application/json'
                }
                else {
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
                }
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all applications
    .DESCRIPTION
    Retrieve all applications
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciApplications {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                    Position=0,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications"            

            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Applications = ParseApplications($Result)
            Write-Output $Applications
        }
    }
}

<#
    .SYNOPSIS
    Add a new application
    .DESCRIPTION
    Add a new application
    .PARAMETER name
    Name of the application
    .PARAMETER priority
    Application priority (Critical, High, Medium or Low). Default is Medium.
    .PARAMETER businessEntity
    Business entity ID to attach the application to
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Add-OciApplication {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Name of the application")][String]$name,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Application priority (Critical, High, Medium or Low). Default is Medium.")][ValidateSet("Critical", "High", "Medium", "Low")][String]$priority="Medium",
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Business entity ID to attach the application to")][String]$businessEntity,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Business entity ID to attach the application to")][Switch]$ignoreShareViolations,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }

    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/applications"
 
        if ($fromTime -or $toTime -or $expand) {
            $Uri += '?'
            $Separator = ''
            if ($fromTime) {
                $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($toTime) {
                $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($expand) {
                $Uri += "$($Separator)expand=$expand"
            }
        }
 
        try {
            if ($businessEntity) {
                $Body = ConvertTo-Json @{name=$name;priority=$priority;businessEntity=@{id=$businessEntity};ignoreShareViolations=$($ignoreShareViolations.IsPresent)} -Compress
            }
            else {
                $Body = ConvertTo-Json @{name=$name;priority=$priority;ignoreShareViolations=$($ignoreShareViolations.IsPresent)} -Compress
            }
            Write-Verbose "Body: $Body"
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }
           
        $Application = ParseApplications($Result)
        Write-Output $Application
    }
}

# TODO: Implemet / Test unassigning of applications from assets
<#
    .SYNOPSIS
    Bulk un-assign applications from assets
    .DESCRIPTION
    Request body should contain a list application ids mapped to a list of asset ids, grouped by type, example: <br/>

<pre>
[
    {
        "123": [
            {
                "objectType": "Qtree",
                "targets": [
                    "11299",
                    "11305"
                ]
            },
            {
                "objectType": "InternalVolume",
                "targets": [
                    "11299",
                    "11305"
                ]
            }
        ]
    },
    {
        "456": [
            {
                "objectType": "VirtualMachine",
                "targets": [
                    "2052",
                    "8739"
                ]
            }
        ]
    }
]
</pre>
            
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Remove-OciApplicationsFromAssets {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                    Position=0,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications/assets"           
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                if ('DELETE' -match 'PUT|POST') {
                    Write-Verbose "Body: "
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body "" -ContentType 'application/json'
                }
                else {
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
                }
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

# TODO: Implement / Test
<#
    .SYNOPSIS
    Bulk assign applications to assets
    .DESCRIPTION
    Request body should contain a list application ids mapped to a list of asset ids, grouped by type, example: <br/>

<pre>
[
    {
        "123": [
            {
                "objectType": "Qtree",
                "targets": [
                    "11299",
                    "11305"
                ]
            },
            {
                "objectType": "InternalVolume",
                "targets": [
                    "11299",
                    "11305"
                ]
            }
        ]
    },
    {
        "456": [
            {
                "objectType": "VirtualMachine",
                "targets": [
                    "2052",
                    "8739"
                ]
            }
        ]
    }
]
</pre>     
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Add-OciApplicationsToAssets {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                    Position=0,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications/assets"           
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                if ('PATCH' -match 'PUT|POST') {
                    Write-Verbose "Body: "
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body "" -ContentType 'application/json'
                }
                else {
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers
                }
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Remove an application
    .DESCRIPTION
    Remove an application
    .PARAMETER id
    Id of application to delete
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Remove-OciApplication {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of application to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications/$id"
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Application = ParseApplications($Result)
            Write-Output $Application
        }
    }
}

<#
    .SYNOPSIS
    Retrieve application
    .DESCRIPTION
    Retrieve application
    .PARAMETER id
    Id of application to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciApplication {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of application to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications/$id"
                      
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
            
            $Application = ParseApplications($Result)
            Write-Output $Application
        }
    }
}

<#
    .SYNOPSIS
    Update an application
    .DESCRIPTION
    Update an application  
    .PARAMETER id
    Id of application to update 
    .PARAMETER priority
    Application priority (Critical, High, Medium or Low). Default is Medium.
    .PARAMETER businessEntity
    Business entity ID to attach the application to
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Update-OciApplication {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of application to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Application priority (Critical, High, Medium or Low). Default is Medium.")][ValidateSet("Critical", "High", "Medium", "Low")][String]$priority="Medium",
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Business entity ID to attach the application to")][String]$businessEntity,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Business entity ID to attach the application to")][Switch]$ignoreShareViolations,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                if ($businessEntity) {
                    $Body = ConvertTo-Json @{name=$name;priority=$priority;businessEntity=@{id=$businessEntity};ignoreShareViolations=$($ignoreShareViolations.IsPresent)} -Compress
                }
                else {
                    $Body = ConvertTo-Json @{name=$name;priority=$priority;ignoreShareViolations=$($ignoreShareViolations.IsPresent)} -Compress
                }
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Application = ParseApplications($Result)
            Write-Output $Application
        }
    }
}

# TODO: Implement / Test
<#
    .SYNOPSIS
    Bulk un-assign application from assets
    .DESCRIPTION
    Request body should contain a list of asset ids, grouped by type, example: <br/>

<pre>
[
    {
        "objectType": "StoragePool"
        "targets": [
            "11299",
            "11305"
        ]
    },
    {
        "objectType": "VirtualMachine"
        "targets": [
            "2052",
            "8739"
        ]
    }
]
</pre>
            
    .PARAMETER id
    Id of application to un-assign from assets
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Bulk-OciUnAssignApplicationFromAssets {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of application to un-assign from assets",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@()
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications/$id/assets"           
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                if ('DELETE' -match 'PUT|POST') {
                    Write-Verbose "Body: "
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body "" -ContentType 'application/json'
                }
                else {
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
                }
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve assets for application
    .DESCRIPTION
    Retrieve assets for application
    .PARAMETER id
    Id of application to retrieve assets for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciAssetsByApplication {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of application to retrieve assets for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications/$id/assets"
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

# TODO: Implement / Test
<#
    .SYNOPSIS
    Bulk assign application to assets
    .DESCRIPTION
    Request body should contain lists of asset ids, grouped by type, example: <br/>

<pre>
[
    {
        "objectType": "Volume",
        "targets": [
            "11299",
            "11305"
        ]
    },
    {
        "objectType": "VirtualMachine",
        "targets": [
            "2052",
            "8739"
        ]
    }
]
</pre>
            
    .PARAMETER id
    Id of application to assign to assets
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Bulk-OciAssignApplicationToAssets {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of application to assign to assets",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@()
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications/$id/assets"
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                if ('PATCH' -match 'PUT|POST') {
                    Write-Verbose "Body: "
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body "" -ContentType 'application/json'
                }
                else {
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers
                }
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve compute resources by application
    .DESCRIPTION
    Retrieve compute resources by application
    .PARAMETER id
    Id of application to retrieve compute resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciComputeResourcesByApplication {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of application to retrieve compute resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=9,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications/$id/computeResources"

            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
            
            $ComputeResources = ParseComputeResources($Result)
            Write-Output $ComputeResources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage resources by application
    .DESCRIPTION
    Retrieve storage resources by application
    .PARAMETER id
    Id of application to retrieve storage resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciStorageResourcesByApplication {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of application to retrieve storage resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/applications/$id/storageResources"

            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
            
            $StorageResources = ParseStorageResources($Result)
            Write-Output $StorageResources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all business entities
    .DESCRIPTION
    Retrieve all business entities
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciBusinessEntities {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                   Position=0,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/businessEntities"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }
           
        Write-Output $Result
    }
}

<#
    .SYNOPSIS
    Add a new business entity
    .DESCRIPTION
    Add a new business entity
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Add-OciBusinessEntity {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                   Position=0,
                   HelpMessage="Tenant.")][String]$Tenant,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")][String]$LineOfBusiness,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")][String]$BusinessUnit,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")][String]$Project,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/businessEntities"
 
        try {
            $Body = @{tenant=$Tenant;lob=$LineOfBusiness;businessUnit=$BusinessUnit;project=$project} | ConvertTo-Json -Compress
            Write-Verbose "Body: $Body"
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'            
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }
           
        Write-Output $Result
    }
}

<#
    .SYNOPSIS
    Remove a business entity
    .DESCRIPTION
    Remove a business entity
    .PARAMETER id
    Id of business entity to remove
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Remove-OciBusinessEntity {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of business entity to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/businessEntities/$id"
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve business entity with empty fields set to N/A
    .DESCRIPTION
    Retrieve business entity with empty fields set to N/A
    .PARAMETER id
    Id of business entity to retrieve
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciBusinessEntity {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of business entity to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/businessEntities/$id"
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all datastores
    .DESCRIPTION
    Retrieve all datastores
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER limit
    Number of datastores per page (range: 0-50, default: 0)
    .PARAMETER offset
    Offset to be used with limit
    .PARAMETER sort
    Performance metric for sorting (Default iops.total)
    .PARAMETER performance
    Return related Performance
    .PARAMETER hosts
    Return list of related Hosts
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciDatastores {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                    Position=0,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Number of datastores per page (range: 0-50, default: 0)")][Long]$limit=0,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Offset to be used with limit")][Long]$offset=0,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            # OCI allows to only fetch maximum 50 items, thus we need to repeat the command if no limit is specified to fetch all items
            if ($Limit -eq 0) {
                $FetchAll = $true
                $Limit = 50
            }

            $Uri = $($Server.BaseUri) + "/rest/v1/assets/dataStores"
            
            $Uri += '?'
            $Separator = ''
            if ($limit) {
                $Uri += "$($Separator)limit=$((Get-Variable 'limit').Value)"
                $Separator = '&'
            }
            if ($limit -and $offset) {
                $Uri += "$($Separator)offset=$((Get-Variable 'offset').Value)"
                $Separator = '&'
            }
            if ($expand) {
                $Uri += "$($Separator)expand=$expand"
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
            
            $Datastores = ParseDatastores($Result)
                  
            if ($Datastores) { Write-Output $Datastores }

            if ($FetchAll -and @($Datastores).Count -eq $Limit) {
                $Offset += $Limit
                Get-OciDatastores -fromTime $fromTime -toTime $toTime -limit $limit -offset $offset
            }
        }
    }
}

<#
    .SYNOPSIS
    Retrieve total count of datastores.
    .DESCRIPTION
    Retrieve total count of datastores.
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciDatastoreCount {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                   Position=0,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/dataStores/count"
      
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }
           
        Write-Output $Result.value
    }
}

<#
    .SYNOPSIS
    Retrieve one datastore
    .DESCRIPTION
    Retrieve one datastore
    .PARAMETER id
    Id of datastore to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER hosts
    Return list of related Hosts
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciDatastore {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of datastore to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Hosts")][Switch]$hosts,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
        $switchparameters=@("performance","hosts","vmdks","datasources","storageResources","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/dataStores/$id"
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Datastore = ParseDatastores($Result)
            Write-Output $Datastore
        }
    }
}

# TODO: Implement / Test
<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Delete annotations from object   
    .PARAMETER id
    Id of datastore where annotation should be deleted
    .PARAMATER annotationId
    Id of annotation to delete. If no annotation is specified, all annotations will be deleted
    .PARAMETER definition
    Return related Definition
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Remove-OciAnnotationsByDatastore {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of datastore to delete annotations from",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Id of annotation to delete")][Long]$annotationId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $Uri = $CurrentOciServer.BaseUri + "/rest/v1/assets/dataStores/$id/annotations"
 
        try {
            $Body = ConvertTo-Json @($annotationId | % { @{id=$_} }) -Compress
            Write-Verbose "Body: $Body"
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body "" -ContentType 'application/json'
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }
       
        Write-Output $Result
    }
}

<#
    .SYNOPSIS
    Retrieve annotations by datastore
    .DESCRIPTION
    Retrieve annotations by datastore
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciAnnotationsByDatastore {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/dataStores/$id/annotations"            
 
            if ($expand) {
                $Uri += "?$($Separator)expand=$expand"
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
            
            $Annotations = ParseAnnotations($Result)
            
            Write-Output $Annotations
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for datastore
    .DESCRIPTION
    Update annotations for datastore      
    .PARAMETER id
    Id of datastore to update
    .PARAMETER annotationId
    Annotation ID
    .PARAMETER value
    Annotation value
    .PARAMETER definition
    Return related Definition
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Update-OciAnnotationsByDatastore {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of datastore to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Annotation ID")][Long]$annotationId,
        [parameter(Mandatory=$True,
                    Position=2,
                    HelpMessage="Annotation value")][String]$value,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/dataStores/$id/annotations"            
 
        if ($expand) {
            $Uri += "?$($Separator)expand=$expand"
        }
 
        try {
            $Body = ConvertTo-Json @(@{rawValue=$value;definition=@{id=$annotationId.ToString()}}) -Compress -Depth 3
            Write-Verbose "Body: $Body"
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }

        Write-Output $Result
    }
}

<#
    .SYNOPSIS
    Retrieve datasources of a datastore.
    .DESCRIPTION
    Retrieve datasources of a datastore.
    .PARAMETER id
    Id of datastore to retrieve datasources for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciDatasourcesByDataStore {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of datastore to retrieve datasources for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/dataStores/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
            
            $Datasources = ParseDatasources($Result)
            
            Write-Output $Datasources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all hosts mapped to a datastore.
    .DESCRIPTION
    Retrieve all hosts mapped to a datastore.
    .PARAMETER id
    Id of the datastore to retrieve the hosts
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER virtualMachines
    Return list of related Virtual machines
    .PARAMETER dataCenter
    Return related Data center
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER clusterHosts
    Return list of related Cluster hosts
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciHostsByDatastore {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of the datastore to retrieve the hosts",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Virtual machines")][Switch]$virtualMachines,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Data center")][Switch]$dataCenter,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Cluster hosts")][Switch]$clusterHosts,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                   Position=14,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","applications","virtualMachines","dataCenter","annotations","clusterHosts","datasources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/dataStores/$id/hosts"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Hosts = ParseHosts($Result)
            
            if ($Hosts) {
                Write-Output $Hosts
            }
        }
    }
}

<#
    .SYNOPSIS
    Retrieve datastore performance data
    .DESCRIPTION
    Retrieve datastore performance data
    .PARAMETER id
    Id of datastore to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER history
    Return list of related History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciDatastorePerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of datastore to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/dataStores/$id/performance"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all storage resources mapped to a datastore.
    .DESCRIPTION
    Retrieve all storage resources mapped to a datastore.
    .PARAMETER id
    Id of the datastore to retrieve the storage resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciStorageResourcesByDatastore {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of the datastore to retrieve the storage resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/dataStores/$id/storageResources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            $StorageResources = ParseStorageResources($Result)
            Write-Output $StorageResources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all Vmdks belonging to a datastore.
    .DESCRIPTION
    Retrieve all Vmdks belonging to a datastore.
    .PARAMETER id
    Id of the datastore to retrieve the Vmdks
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStore
    Return related Datastore
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER virtualMachine
    Return related Virtual machine
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciVmdksByDatastore {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of the datastore to retrieve the Vmdks",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Datastore")][Switch]$dataStore,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return related Virtual machine")][Switch]$virtualMachine,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","dataStore","storageResources","virtualMachine","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/dataStores/$id/vmdks"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Vmdks = ParseVmdks($Result)
           
            Write-Output $Vmdks
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage pool disks
    .DESCRIPTION
    Retrieve storage pool disks
    .PARAMETER id
    Id of storage pool disk to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performance
    Return related Performance
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER backendVolumes
    Return list of related Backend volumes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciDisk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage pool disk to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Backend volumes")][Switch]$backendVolumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","storagePools","performance","storageResources","backendVolumes","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/disks/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Disks = ParseDisks($Result)
            Write-Output $Disks
        }
    }
}

# TODO: Test / Implement
<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
    .PARAMETER definition
    Return related Definition
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Remove-OciAnnotationsByDisk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/disks/$id/annotations"
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations of disk
    .DESCRIPTION
    Retrieve annotations of disk
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciAnnotationsByDisk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/disks/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Annotations = ParseAnnotations($Result)
            Write-Output $Annotations
        }
    }
}

# TODO: Test / Implement
<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
    .PARAMETER definition
    Return related Definition
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Update-OciAnnotationsByDisk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/disks/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve backend volumes of a virtual disk.
    .DESCRIPTION
    Retrieve backend volumes of a virtual disk.
    .PARAMETER id
    Id of the virtual disk to retrieve backend volumes for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER virtualStoragePools
    Return list of related Virtual storage pools
    .PARAMETER virtualizer
    Return related Virtualizer
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER autoTierPolicy
    Return related Auto tier policy
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER qtree
    Return related Qtree
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciBackendVolumesByDisk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of the virtual disk to retrieve backend volumes for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Virtual storage pools")][Switch]$virtualStoragePools,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Virtualizer")][Switch]$virtualizer,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Auto tier policy")][Switch]$autoTierPolicy,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=19,
                    HelpMessage="Return related Qtree")][Switch]$qtree,
        [parameter(Mandatory=$False,
                    Position=20,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=21,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","virtualStoragePools","virtualizer","internalVolume","autoTierPolicy","ports","storageNodes","replicaSources","datasources","annotations","qtree","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/disks/$id/backendVolumes"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Volumes = ParseVolumes($Result)
            Write-Output $Volumes
        }
    }
}

<#
    .SYNOPSIS
    Retrieve datasources of a disk.
    .DESCRIPTION
    Retrieve datasources of a disk.
    .PARAMETER id
    Id of disk to retrieve datasources for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciDatasourcesByDisk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of disk to retrieve datasources for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/disks/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Datasources = ParseDatasources($Result)

            Write-Output $Datasources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one disk performance
    .DESCRIPTION
    Retrieve one disk performance
    .PARAMETER id
    Id of disk to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER history
    Return list of related History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciDiskPerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of disk to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/disks/$id/performance"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage pools for disk
    .DESCRIPTION
    Retrieve storage pools for disk
    .PARAMETER id
    Id of disk to retrieve storage pools for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciStoragePoolsByDisk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of disk to retrieve storage pools for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=14,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","storageResources","internalVolumes","volumes","disks","datasources","storageNodes","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/disks/$id/storagePools"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $StoragePools = ParseStoragePools($Result)
            Write-Output $StoragePools
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage resources for disk
    .DESCRIPTION
    Retrieve storage resources for disk
    .PARAMETER id
    Id of disk to retrieve resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciStorageResourcesByDisk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of disk to retrieve resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/disks/$id/storageResources"
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            $StorageResources = ParseStorageResources($Result)
            Write-Output $StorageResources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all fabrics
    .DESCRIPTION
    Retrieve all fabrics
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER limit
    Number of fabrics per page.
    .PARAMETER offset
    Offset to be used with limit
    .PARAMETER switches
    Return list of related Switches
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciFabrics {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                    Position=0,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Number of fabrics per page (range: 0-50, default: 0)")][Long]$limit=0,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Offset to be used with limit")][Long]$offset=0,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Switches")][Switch]$switches,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("switches","datasources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            # OCI allows to only fetch maximum 50 items thus we need to repeat the command if no limit is specified to fetch all items
            if ($Limit -eq 0) {
                $FetchAll = $true
                $Limit = 50
            }

            $Uri = $Server.BaseUri + "/rest/v1/assets/fabrics"                      
 
            $Uri += '?'
            $Separator = ''
            if ($fromTime) {
                $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($toTime) {
                $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($limit) {
                $Uri += "$($Separator)limit=$((Get-Variable 'limit').Value)"
                $Separator = '&'
            }
            if ($limit -and $offset) {
                $Uri += "$($Separator)offset=$((Get-Variable 'offset').Value)"
                $Separator = '&'
            }
            if ($expand) {
                $Uri += "$($Separator)expand=$expand"
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Fabrics = ParseFabrics($Result)
            if ($Fabrics)  { Write-Output $Fabrics }

            if ($FetchAll -and @($Fabrics).Count -eq $Limit) {
                $Offset += $Limit
                Get-OciFabrics -fromTime $fromTime -toTime $toTime -limit $limit -offset $offset -switches:$switches -datasources:$datasources -Server $Server
            }
        }
    }
}

<#
    .SYNOPSIS
    Retrieve total count of fabrics.
    .DESCRIPTION
    Retrieve total count of fabrics.
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciFabricCount {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                   Position=0,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/fabrics/count"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }
       
        Write-Output $Result
    }
}

<#
    .SYNOPSIS
    Retrieve one fabric
    .DESCRIPTION
    Retrieve one fabric
    .PARAMETER id
    Id of fabric to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER switches
    Return list of related Switches
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciFabric {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of fabric to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Switches")][Switch]$switches,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("switches","datasources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/fabrics/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Fabric = ParseFabrics($Result)
            Write-Output $Fabric
        }
    }
}

<#
    .SYNOPSIS
    Retrieve Datasources for one fabric
    .DESCRIPTION
    Retrieve Datasources for one fabric
    .PARAMETER id
    Id of fabric to retrieve datasources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciDatasourcesByFabric {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of fabric to retrieve datasources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/fabrics/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Datasources = ParseDatasources($Result)
            Write-Output $Datasources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve Ports for one fabric
    .DESCRIPTION
    Retrieve Ports for one fabric
    .PARAMETER id
    Id of fabric to retrieve ports for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER limit
    Number of ports in fabric to retrieve (range: 0-50, default: 0)
    .PARAMETER offset
    Offset to be used with limit
    .PARAMETER sort
    Performance metric used for sorting (Default iops.total)
    .PARAMETER device
    Return related Device Object
    .PARAMETER fabrics
    Return list of related Fabrics
    .PARAMETER performance
    Return related Performance
    .PARAMETER connectedPorts
    Return list of related Connected ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciPortsByFabric {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of fabric to retrieve ports for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Limit for number of ports in fabric to retrieve")][Long]$limit=0,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Offset to be used with limit")][Long]$offset=0,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="sort will specify the field name on which sorting to be applied")][String]$sort="trafficRate.total",
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return related Device Object")][Switch]$device,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Fabrics")][Switch]$fabrics,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Connected ports")][Switch]$connectedPorts,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                   Position=15,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("device","fabrics","performance","connectedPorts","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            # OCI allows to only fetch maximum 50 items when performance data is requested, thus we need to repeat the command if no limit is specified to fetch all items
            if ($Limit -eq 0) {
                $FetchAll = $true
                $Limit = 50
            }

            $Uri = $Server.BaseUri + "/rest/v1/assets/fabrics/$id/ports"                      

            $Uri += '?'
            $Separator = ''
            if ($fromTime) {
                $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($toTime) {
                $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($sort) {
                $Uri += "$($Separator)sort=$((Get-Variable 'sort').Value)"
                $Separator = '&'
            }
            if ($limit) {
                $Uri += "$($Separator)limit=$((Get-Variable 'limit').Value)"
                $Separator = '&'
            }
            if ($limit -and $offset) {
                $Uri += "$($Separator)offset=$((Get-Variable 'offset').Value)"
                $Separator = '&'
            }
            if ($expand) {
                $Uri += "$($Separator)expand=$expand"
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Ports = ParsePorts($Result)
            if ($Ports) { Write-Output $Ports }

            if ($FetchAll -and @($Ports).Count -eq $Limit) {
                $Offset += $Limit
                Get-OciPortsByFabric -id $id -fromTime $fromTime -toTime $toTime -performance:$performance -performancehistory:$performancehistory -sort $sort -limit $limit -offset $offset -device:$device -fabrics:$fabrics -connectedPorts:$connectedPorts -annotations:$annotations -datasources:$datasources -applications:$applications -Server $Server
            }
        }
    }
}

<#
    .SYNOPSIS
    Retrieve total count of ports by fabric with performance.
    .DESCRIPTION
    Retrieve total count of ports by fabric with performance.
    .PARAMETER id
    Id of fabric to retrieve ports for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciPortsByFabricCount {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of fabric to retrieve ports for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@()
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/fabrics/$id/ports/count"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result.Value
        }
    }
}

<#
    .SYNOPSIS
    Retrieve switches for one fabric
    .DESCRIPTION
    Retrieve switches for one fabric
    .PARAMETER id
    Id of fabric to retrieve switches for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER fabric
    Return related Fabric
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciSwitchesByFabric {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of fabric to retrieve switches for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Fabric")][Switch]$fabric,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("fabric","performance","ports","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/fabrics/$id/switches"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Switches = ParseSwitches($Result)
            Write-Output $Switches
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one file system
    .DESCRIPTION
    
    .PARAMETER id
    Id of file system to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER computeResource
    Return related Compute resource
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciFilesystem {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of file system to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Compute resource")][Switch]$computeResource,
        [parameter(Mandatory=$False,
                   Position=7,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storageResources","vmdks","computeResource")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/fileSystems/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve compute resource for a file system
    .DESCRIPTION
    
    .PARAMETER id
    Id of file system to retrieve the compute resource for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciComputeResourceByFileSystem {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of file system to retrieve the compute resource for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=9,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/fileSystems/$id/computeResource"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage resources for a file system
    .DESCRIPTION
    
    .PARAMETER id
    Id of file system to retrieve the storage resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciStorageResorcesByFileSystem {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of file system to retrieve the storage resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/fileSystems/$id/storageResources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve VMDKs for a file system
    .DESCRIPTION
    
    .PARAMETER id
    Id of file system to retrieve the VMDKs for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStore
    Return related Datastore
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER virtualMachine
    Return related Virtual machine
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciVmdksByFileSystem {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of file system to retrieve the VMDKs for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Datastore")][Switch]$dataStore,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return related Virtual machine")][Switch]$virtualMachine,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","dataStore","storageResources","virtualMachine","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/fileSystems/$id/vmdks"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the topology of a host
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciTopologyByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of the host to retrieve the topology for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/topology/Host/$id"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }

        $Topology = ParseTopologies($Result)
          
        Write-Output $Topology
    }
}

<#
    .SYNOPSIS
    Retrieve the topology of a storage system
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciTopologyByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of the storage system to retrieve the topology for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/topology/Storage/$id"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }

        $Topology = ParseTopologies($Result)
          
        Write-Output $Topology
    }
}

<#
    .SYNOPSIS
    Retrieve all hosts
    .DESCRIPTION
    
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER limit
    Number of hosts per page (range: 0-50, default: 0)
    .PARAMETER offset
    Offset to be used with limit
    .PARAMETER sort
    Performance metric for sorting (Default diskIops.total)
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER virtualMachines
    Return list of related Virtual machines
    .PARAMETER dataCenter
    Return related Data center
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER clusterHosts
    Return list of related Cluster hosts
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciHosts {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                    Position=0,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Number of hosts per page  (range: 0-50, default: 0)")][Long]$limit=0,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Offset to be used with limit")][Long]$offset=0,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Performance metric for sorting (Default diskIops.total)")][String]$sort="diskIops.total",
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Virtual machines")][Switch]$virtualMachines,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Data center")][Switch]$dataCenter,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Cluster hosts")][Switch]$clusterHosts,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                   Position=17,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","applications","virtualMachines","dataCenter","annotations","clusterHosts","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            # OCI allows to only fetch maximum 50 items, thus we need to repeat the command if no limit is specified to fetch all items
            if ($Limit -eq 0) {
                $FetchAll = $true
                $Limit = 50
            }

            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts"                      
 
            $Uri += '?'
            $Separator = ''
            if ($fromTime) {
                $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($toTime) {
                $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($sort) {
                $Uri += "$($Separator)sort=$((Get-Variable 'sort').Value)"
                $Separator = '&'
            }
            if ($limit) {
                $Uri += "$($Separator)limit=$((Get-Variable 'limit').Value)"
                $Separator = '&'
            }
            if ($limit -and $offset) {
                $Uri += "$($Separator)offset=$((Get-Variable 'offset').Value)"
                $Separator = '&'
            }
            if ($expand) {
                $Uri += "$($Separator)expand=$expand"
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Hosts = ParseHosts($Result)

            if ($Hosts) { Write-Output $Hosts }

            if ($FetchAll -and @($Hosts).Count -eq $Limit) {
                $Offset += $Limit
                Get-OciHosts -fromTime $fromTime -toTime $toTime -performance:$performance -performancehistory:$performancehistory -sort $sort -limit $limit -offset $offset -ports:$ports -storageResources:$storageResources -fileSystems:$fileSystems -applications:$applications -virtualMachines:$virtualMachines -dataCenter:$dataCenter -annotations:$annotations -clusterHosts:$clusterHosts -datasources:$datasources -Server $Server
            }
        }
    }
}

<#
    .SYNOPSIS
    Retrieve total count of hosts.
    .DESCRIPTION
    Retrieve total count of hosts.
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciHostCount {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/count"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }

        Write-Output $Result.Value
    }
}

<#
    .SYNOPSIS
    Retrieve one host
    .DESCRIPTION
    Retrieve one host
    .PARAMETER id
    Id of host to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER virtualMachines
    Return list of related Virtual machines
    .PARAMETER dataCenter
    Return related Data center
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER clusterHosts
    Return list of related Cluster hosts
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of host to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Virtual machines")][Switch]$virtualMachines,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Data center")][Switch]$dataCenter,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Cluster hosts")][Switch]$clusterHosts,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","applications","virtualMachines","dataCenter","annotations","clusterHosts","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
            
            $Hosts = ParseHosts($Result)
            
            Write-Output $Hosts
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from host
    .DESCRIPTION
    Delete annotations from host             
    .PARAMETER id
    Id of object to delete
    .PARAMETER definition
    Return related Definition
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Remove-OciAnnotationsByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][PSObject[]]$annotations,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/annotations"
 
            try {
                if (!$Annotations) {
                    $Annotations = Get-OciAnnotationsByHost -id $id -Server $Server
                }
                $Definitions = @()
                foreach ($Annotation in $Annotations) {
                    $Definitions += @{definition=@{id=$Annotation.id}} 
                }
                $Body = ConvertTo-Json $Definitions
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations of host
    .DESCRIPTION
    Retrieve annotations of host
    .PARAMETER id
    Id of host to retrieve annotations for
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
    .PARAMETER server
    OCI Server to connect to
#>
function Global:Get-OciAnnotationsByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of host to retrieve annotations for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $($Server.BaseUri) + "/rest/v1/assets/hosts/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations of host
    .DESCRIPTION
    Update annotations of host     
    .PARAMETER id
    Id of object to update
    .PARAMETER annotation
    Annotation
    .PARAMETER rawValue
    Annotation value to set for host
#>
function Global:Update-OciAnnotationByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Annotation")][PSObject]$annotation,
        [parameter(Mandatory=$True,
                    Position=2,
                    HelpMessage="Annotation value to set for host")][String]$rawValue,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/annotations"
 
            try {
                $Body = @"
[
    {
        "rawValue": "$rawValue",
        "definition": 
            {
                "id": "$($annotation.id)"
            }
    }
]
"@
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk un-assign applications from asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciUnAssignApplicationsFromAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the applications of object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Get-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk assign applications to asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciAssignApplicationsToAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Add applications for object
    .DESCRIPTION
    Request body should contain only one valid application id, example: <br/>

<pre>
{
    "id":"12345"
}
</pre>
            
    .PARAMETER id
    Id of object to update
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Update-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete application from object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to delete application from
    .PARAMETER appId
    Id of application to delete from object
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Remove-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete application from",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Id of application to delete from object")][Long]$appId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $($Server.BaseUri) + "/rest/v1/assets/hosts/$id$/applications/$appId"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the hosts from same cluster of host
    .DESCRIPTION
    
    .PARAMETER id
    Id of host to retrieve cluster hosts for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER virtualMachines
    Return list of related Virtual machines
    .PARAMETER dataCenter
    Return related Data center
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER clusterHosts
    Return list of related Cluster hosts
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciClusterHostsByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of host to retrieve cluster hosts for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Virtual machines")][Switch]$virtualMachines,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Data center")][Switch]$dataCenter,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Cluster hosts")][Switch]$clusterHosts,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=15,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","applications","virtualMachines","dataCenter","annotations","clusterHosts","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/clusterHosts"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the data center of host
    .DESCRIPTION
    
    .PARAMETER id
    Id of host to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
#>
function Global:Get-OciDataCenterByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of host to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@()
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/dataCenter"                     
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve datasources of a host.
    .DESCRIPTION
    
    .PARAMETER id
    Id of host to retrieve datasources for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
#>
function Global:Get-OciDatasourcesByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of host to retrieve datasources for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/datasources"                      
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the file systems of host
    .DESCRIPTION
    
    .PARAMETER id
    Id of host to retrieve file systems for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER computeResource
    Return related Compute resource
#>
function Global:Get-OciFileSystemsByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of host to retrieve file systems for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Compute resource")][Switch]$computeResource,
        [parameter(Mandatory=$False,
                   Position=7,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storageResources","vmdks","computeResource")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/fileSystems"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one host performance
    .DESCRIPTION
    
    .PARAMETER id
    Id of host to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER history
    Return list of related History
#>
function Global:Get-OciHostPerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of host to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/performance"                      
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the ports of host
    .DESCRIPTION
    
    .PARAMETER id
    Id of host to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER device
    Return related Device Object
    .PARAMETER fabrics
    Return list of related Fabrics
    .PARAMETER performance
    Return related Performance
    .PARAMETER connectedPorts
    Return list of related Connected ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciPortsByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of host to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Device Object")][Switch]$device,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Fabrics")][Switch]$fabrics,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Connected ports")][Switch]$connectedPorts,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("device","fabrics","performance","connectedPorts","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/ports"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all storage resources by host
    .DESCRIPTION
    
    .PARAMETER id
    Id of host to retrieve storage resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageResourcesByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of host to retrieve storage resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/storageResources"                      
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the virtual machines of host
    .DESCRIPTION
    
    .PARAMETER id
    Id of host to retrieve virtual machines  for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER dataStore
    Return related Datastore
    .PARAMETER host
    Return related Host
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVirtualMachinesByHost {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of host to retrieve virtual machines  for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Datastore")][Switch]$dataStore,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return related Host")][Switch]$host,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=15,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","dataStore","host","vmdks","applications","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
 
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/hosts/$id/virtualMachines"
            
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve internal volume
    .DESCRIPTION
    
    .PARAMETER id
    Id of internal volume to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePool
    Return related Storage pool
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return related Storage pool")][Switch]$storagePool,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=17,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePool","volumes","storageNodes","annotations","datasources","replicaSources","qtrees","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $InternalVolume = ParseInternalVolumes($Result)
            Write-Output $InternalVolume
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciAnnotationsByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/annotations"
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations for object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
        .PARAMETER definition
        Return related Definition
#>
function Global:Get-OciAnnotationsByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciAnnotationsByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk un-assign applications from internal volume
    .DESCRIPTION
    Bulk un-assign applications from internal volume 
    .PARAMETER id
    Id of internal volume to update
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Remove-OciApplicationsFromInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="List of application IDs",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$applicationId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/applications"            
 
            if ($expand) {
                $Uri += "?$($Separator)expand=$expand"
            }
 
            try {
                $Body = ConvertTo-Json @($applicationId | % { @{id=$_} }) -Compress
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the applications of object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Get-OciApplicationsByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk assign applications to internal volume
    .DESCRIPTION
    Bulk assign applications to internal volume     
    .PARAMETER id
    Id of object to update
    .PARAMETER applicationId
    List of application IDs
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Add-OciApplicationsToInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="List of application IDs",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$applicationId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        $applicationId = @($applicationId)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/applications"            
 
            if ($expand) {
                $Uri += "?$($Separator)expand=$expand"
            }
 
            try {
                $Body = ConvertTo-Json @($applicationId | % { @{id=$_} }) -Compress
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Add applications for object
    .DESCRIPTION
    Request body should contain only one valid application id, example: <br/>

<pre>
{
    "id":"12345"
}
</pre>
            
    .PARAMETER id
    Id of object to update
    .PARAMETER applicationId
    Valid application id which should be associated
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Update-OciApplicationsByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Valid application id which should be associated")][String]$applicationId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = "{ `"id`": `"$applicationId`" }"
                    Write-Verbose "Body: $Body"
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete application from internal volume
    .DESCRIPTION
    Delete application from internal volume
    .PARAMETER id
    Id of object to delete application from
    .PARAMETER appId
    Id of application to delete from object
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Remove-OciApplicationsByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume to delete application from",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Id of application to delete from object")][Long]$appId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/applications/$appId"            
 
            if ($expand) {
                $Uri += "?$($Separator)expand=$expand"
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all compute resources for an internal volume
    .DESCRIPTION
    
    .PARAMETER id
    Id of internal volume to retrieve compute resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciComputeResourcesByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume to retrieve compute resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=9,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/computeResources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all data stores for an internal volume
    .DESCRIPTION
    
    .PARAMETER id
    Id of internal volume to retrieve data stores for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER hosts
    Return list of related Hosts
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciDataStoresByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume to retrieve data stores for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Hosts")][Switch]$hosts,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","hosts","vmdks","datasources","storageResources","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/dataStores"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the datasources for an internal volume
    .DESCRIPTION
    
    .PARAMETER id
    Id of internal volume to retrieve datasource for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
#>
function Global:Get-OciDatasourcesByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume to retrieve datasource for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
            
            $Datasources = ParseDatasources($Result)
            Write-Output $Datasources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve internal volume performance
    .DESCRIPTION
    
    .PARAMETER id
    Id of internal volume to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
        .PARAMETER history
        Return list of related History
#>
function Global:Get-OciInternalVolumePerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/performance"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve qtrees for one internal volume
    .DESCRIPTION
    
    .PARAMETER id
    Id of internal volume to retrieve storage qtrees for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER volumes
    Return list of related Volumes
#>
function Global:Get-OciQtreesByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume to retrieve storage qtrees for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                   Position=10,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","internalVolume","shares","annotations","applications","volumes")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/qtrees"          
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Qtrees = ParseQtrees($Result)
            Write-Output $Qtrees
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all replica source internal volumes for an internal volume
    .DESCRIPTION
    
    .PARAMETER id
    Id of internal volume to retrieve replica source internal volumes for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePool
    Return related Storage pool
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciSourceInternalVolumesByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume to retrieve replica source internal volumes for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return related Storage pool")][Switch]$storagePool,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=17,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePool","volumes","storageNodes","annotations","datasources","replicaSources","qtrees","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/replicaSources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all storage nodes for an internal volume
    .DESCRIPTION
    
    .PARAMETER id
    Id of internal volume to retrieve storage nodes for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER partner
    Return related HA partner
    .PARAMETER performance
    Return related Performance
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageNodesByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume to retrieve storage nodes for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related HA partner")][Switch]$partner,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","partner","performance","datasources","storagePools","ports","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/storageNodes"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $StorageNodes = ParseStorageNodes($Result)
            Write-Output $StorageNodes
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all volumes for an internal volume
    .DESCRIPTION
    
    .PARAMETER id
    Id of internal volume to retrieve volumes for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER virtualStoragePools
    Return list of related Virtual storage pools
    .PARAMETER virtualizer
    Return related Virtualizer
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER autoTierPolicy
    Return related Auto tier policy
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER qtree
    Return related Qtree
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVolumesByInternalVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of internal volume to retrieve volumes for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Virtual storage pools")][Switch]$virtualStoragePools,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Virtualizer")][Switch]$virtualizer,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Auto tier policy")][Switch]$autoTierPolicy,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=19,
                    HelpMessage="Return related Qtree")][Switch]$qtree,
        [parameter(Mandatory=$False,
                    Position=20,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","virtualStoragePools","virtualizer","internalVolume","autoTierPolicy","ports","storageNodes","replicaSources","datasources","annotations","qtree","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/internalVolumes/$id/volumes"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Volues = ParseVolumes($Result)
            Write-Output $Volumes
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one port
    .DESCRIPTION
    
    .PARAMETER id
    Id of port to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER device
    Return related Device Object
    .PARAMETER fabrics
    Return list of related Fabrics
    .PARAMETER performance
    Return related Performance
    .PARAMETER connectedPorts
    Return list of related Connected ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciPort {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of port to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Device Object")][Switch]$device,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Fabrics")][Switch]$fabrics,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Connected ports")][Switch]$connectedPorts,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("device","fabrics","performance","connectedPorts","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciAnnotationsByPort {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations for object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
        .PARAMETER definition
        Return related Definition
#>
function Global:Get-OciAnnotationsByPort {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciAnnotationsByPort {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/annotations"                      
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: "
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk un-assign applications from asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciUnAssignApplicationsFromAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                Write-Verbose "Body: "
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the applications of object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Get-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk assign applications to asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciAssignApplicationsToAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Add applications for object
    .DESCRIPTION
    Request body should contain only one valid application id, example: <br/>

<pre>
{
    "id":"12345"
}
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Update-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: "
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve connected ports for one port
    .DESCRIPTION
    
    .PARAMETER id
    Id of port to retrieve connected port for
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER device
    Return related Device Object
    .PARAMETER fabrics
    Return list of related Fabrics
    .PARAMETER performance
    Return related Performance
    .PARAMETER connectedPorts
    Return list of related Connected ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciConnectedPortsByPort {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of port to retrieve connected port for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Device Object")][Switch]$device,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Fabrics")][Switch]$fabrics,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Connected ports")][Switch]$connectedPorts,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("device","fabrics","performance","connectedPorts","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/connectedPorts"           
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve datasources of a port.
    .DESCRIPTION
    
    .PARAMETER id
    Id of port to retrieve datasources for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
#>
function Global:Get-OciDatasourcesByPort {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of port to retrieve datasources for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one device for port
    .DESCRIPTION
    
    .PARAMETER id
    Id of port to retrieve device
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
#>
function Global:Get-OciDeviceByPort {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of port to retrieve device",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@()
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/device"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve Fabric for port
    .DESCRIPTION
    
    .PARAMETER id
    Id of port to retrieve fabric
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER switches
    Return list of related Switches
    .PARAMETER datasources
    Return list of related Datasources
#>
function Global:Get-OciFabricsByPort {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of port to retrieve fabric",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Switches")][Switch]$switches,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("switches","datasources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/fabrics"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one port performance
    .DESCRIPTION
    
    .PARAMETER id
    Id of port to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER history
    Return list of related History
#>
function Global:Get-OciPortPerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of port to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/ports/$id/performance"
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one Qtree
    .DESCRIPTION
    
    .PARAMETER id
    Id of qtree to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER volumes
    Return list of related Volumes
#>
function Global:Get-OciQtree {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of qtree to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                   Position=10,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","internalVolume","shares","annotations","applications","volumes")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations for object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
#>
function Global:Get-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
          
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/annotations"           
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk un-assign applications from asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciUnAssignApplicationsFromAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the applications of object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Get-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk assign applications to asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciAssignApplicationsToAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Add applications for object
    .DESCRIPTION
    Request body should contain only one valid application id, example: <br/>

<pre>
{
    "id":"12345"
}
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Update-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/applications"                      
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete application from object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to delete application from
    .PARAMETER appId
    Id of application to delete from object
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Remove-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete application from",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Id of application to delete from object")][Long]$appId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/applications/$appId"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve internal volume for given qtree
    .DESCRIPTION
    
    .PARAMETER id
    Id of qtree to retrieve internal volume for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePool
    Return related Storage pool
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciInternalVolumeByQtree {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of qtree to retrieve internal volume for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return related Storage pool")][Switch]$storagePool,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=17,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePool","volumes","storageNodes","annotations","datasources","replicaSources","qtrees","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/internalVolume"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve shares for one qtree
    .DESCRIPTION
    
    .PARAMETER id
    Id of qtree to retrieve shares for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER qtree
    Return related Qtree
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER applications
    Return list of related Applications
#>
function Global:Get-OciSharesByQtree {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of qtree to retrieve shares for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Qtree")][Switch]$qtree,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                   Position=8,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","qtree","annotations","applications")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/shares"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage for given qtree
    .DESCRIPTION
    
    .PARAMETER id
    Id of qtree to retrieve storage for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER performance
    Return related Performance
    .PARAMETER protocols
    Return list of related Protocols
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of qtree to retrieve storage for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Protocols")][Switch]$protocols,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=19,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storageNodes","storageResources","storagePools","internalVolumes","volumes","qtrees","shares","ports","datasources","annotations","disks","performance","protocols","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/storage"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve volumes for one qtree
    .DESCRIPTION
    
    .PARAMETER id
    Id of qtree to retrieve volumes for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER virtualStoragePools
    Return list of related Virtual storage pools
    .PARAMETER virtualizer
    Return related Virtualizer
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER autoTierPolicy
    Return related Auto tier policy
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER qtree
    Return related Qtree
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVolumesByQtree {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of qtree to retrieve volumes for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Virtual storage pools")][Switch]$virtualStoragePools,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Virtualizer")][Switch]$virtualizer,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Auto tier policy")][Switch]$autoTierPolicy,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=19,
                    HelpMessage="Return related Qtree")][Switch]$qtree,
        [parameter(Mandatory=$False,
                    Position=20,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=21,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","virtualStoragePools","virtualizer","internalVolume","autoTierPolicy","ports","storageNodes","replicaSources","datasources","annotations","qtree","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/qtrees/$id/volumes"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Volumes = ParseVolumes($Result)
            Write-Output $Volumes
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one Share
    .DESCRIPTION
    
    .PARAMETER id
    Id of share to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER qtree
    Return related Qtree
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER applications
    Return list of related Applications
#>
function Global:Get-OciShare {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of share to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Qtree")][Switch]$qtree,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                   Position=8,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","qtree","annotations","applications")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations for object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
#>
function Global:Get-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id/annotations"                      
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk un-assign applications from asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciUnAssignApplicationsFromAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the applications of object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Get-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk assign applications to asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciAssignApplicationsToAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Add applications for object
    .DESCRIPTION
    Request body should contain only one valid application id, example: <br/>

<pre>
{
    "id":"12345"
}
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Update-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete application from object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to delete application from
    .PARAMETER appId
    Id of application to delete from object
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Remove-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete application from",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Id of application to delete from object")][Long]$appId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id/applications/{appId}"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve qtree for given share
    .DESCRIPTION
    
    .PARAMETER id
    Id of share to retrieve qtree for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER volumes
    Return list of related Volumes
#>
function Global:Get-OciQtree {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of share to retrieve qtree for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                   Position=10,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","internalVolume","shares","annotations","applications","volumes")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id/qtree"                      
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage for given share
    .DESCRIPTION
    
    .PARAMETER id
    Id of share to retrieve storage for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER performance
    Return related Performance
    .PARAMETER protocols
    Return list of related Protocols
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of share to retrieve storage for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Protocols")][Switch]$protocols,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=19,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storageNodes","storageResources","storagePools","internalVolumes","volumes","qtrees","shares","ports","datasources","annotations","disks","performance","protocols","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/shares/$id/storage"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one storage node
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage node to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER partner
    Return related HA partner
    .PARAMETER performance
    Return related Performance
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageNode {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage node to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related HA partner")][Switch]$partner,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","partner","performance","datasources","storagePools","ports","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storageNodes/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $StorageNodes = ParseStorageNodes($Result)
            Write-Output $StorageNodes
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciAnnotationsByStorageNode {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storageNodes/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations for object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
        .PARAMETER definition
        Return related Definition
#>
function Global:Get-OciAnnotationsByStorageNode {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storageNodes/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciAnnotationsByStorageNode {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storageNodes/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one storage node datasources
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage node to retrieve datasources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
#>
function Global:Get-OciDatasourcesByStorageNode {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage node to retrieve datasources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storageNodes/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one storage node performance
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage node to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER history
    Return list of related History
#>
function Global:Get-OciStorageNodePerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage node to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storageNodes/$id/performance"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all ports by node
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage node to retrieve ports for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER device
    Return related Device Object
    .PARAMETER fabrics
    Return list of related Fabrics
    .PARAMETER performance
    Return related Performance
    .PARAMETER connectedPorts
    Return list of related Connected ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciPortsByStorageNode {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage node to retrieve ports for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Device Object")][Switch]$device,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Fabrics")][Switch]$fabrics,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Connected ports")][Switch]$connectedPorts,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("device","fabrics","performance","connectedPorts","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storageNodes/$id/ports"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all storage pools by node
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage node to retrieve storage pool for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStoragePoolsByNode {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage node to retrieve storage pool for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=14,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","storageResources","internalVolumes","volumes","disks","datasources","storageNodes","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storageNodes/$id/storagePools"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one storage pool
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage pool to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage pool to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","storageResources","internalVolumes","volumes","disks","datasources","storageNodes","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciAnnotationsByStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/annotations"                       
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: "
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations for object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
#>
function Global:Get-OciAnnotationsByStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciAnnotationsByStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one storage pool datasources
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage pool to retrieve datasources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
#>
function Global:Get-OciDatasourcesByStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage pool to retrieve datasources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve Disks for storage pool
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage pool to retrieve disks for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performance
    Return related Performance
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER backendVolumes
    Return list of related Backend volumes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciDisksByStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage pool to retrieve disks for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Backend volumes")][Switch]$backendVolumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","storagePools","performance","storageResources","backendVolumes","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/disks"
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve internal volumes for storage pool
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage pool to retrieve internal volumes for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePool
    Return related Storage pool
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciInternalVolumesByStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage pool to retrieve internal volumes for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return related Storage pool")][Switch]$storagePool,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=17,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePool","volumes","storageNodes","annotations","datasources","replicaSources","qtrees","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/internalVolumes"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one storage pool performance
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage pool to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
        .PARAMETER history
        Return list of related History
#>
function Global:Get-OciStoragePoolPerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage pool to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/performance"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one storage pool storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage pool to retrieve storage for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER performance
    Return related Performance
    .PARAMETER protocols
    Return list of related Protocols
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageByStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage pool to retrieve storage for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Protocols")][Switch]$protocols,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=19,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storageNodes","storageResources","storagePools","internalVolumes","volumes","qtrees","shares","ports","datasources","annotations","disks","performance","protocols","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/storage"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage nodes for storage pool
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage pool to retrieve storage nodes for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER partner
    Return related HA partner
    .PARAMETER performance
    Return related Performance
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageNodesByStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage pool to retrieve storage nodes for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related HA partner")][Switch]$partner,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","partner","performance","datasources","storagePools","ports","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/storageNodes"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve resources for storage pool
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage pool to retrieve resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageResourcesByStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage pool to retrieve resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/storageResources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve volumes for storage pool
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage pool to retrieve volumes for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER virtualStoragePools
    Return list of related Virtual storage pools
    .PARAMETER virtualizer
    Return related Virtualizer
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER autoTierPolicy
    Return related Auto tier policy
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER qtree
    Return related Qtree
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVolumesByStoragePool {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage pool to retrieve volumes for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Virtual storage pools")][Switch]$virtualStoragePools,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Virtualizer")][Switch]$virtualizer,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Auto tier policy")][Switch]$autoTierPolicy,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=19,
                    HelpMessage="Return related Qtree")][Switch]$qtree,
        [parameter(Mandatory=$False,
                    Position=20,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=21,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","virtualStoragePools","virtualizer","internalVolume","autoTierPolicy","ports","storageNodes","replicaSources","datasources","annotations","qtree","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storagePools/$id/volumes"
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Volumes = ParseVolumes($Result)
            Write-Output $Volumes
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all storages
    .DESCRIPTION
    Retrieve all storages
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER sort
    Filter for sorting by metric/s
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER limit
    Number of storages per page.
    .PARAMETER offset
    Offset to be used with limit
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER performance
    Return related Performance
    .PARAMETER protocols
    Return list of related Protocols
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorages {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                    Position=0,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Number of storages per page.")][Long]$limit=0,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Offset to be used with limit")][Long]$offset=0,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Filter for sorting by metric/s")][String]$sort="iops.total",
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=19,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=20,
                    HelpMessage="Return list of related Protocols")][Switch]$protocols,
        [parameter(Mandatory=$False,
                    Position=21,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                   Position=22,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storageNodes","storageResources","storagePools","internalVolumes","volumes","qtrees","shares","ports","datasources","annotations","disks","performance","protocols","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        # OCI allows to only fetch maximum 50 items, thus we need to repeat the command if no limit is specified to fetch all items
        if ($Limit -eq 0) {
            $FetchAll = $true
            $Limit = 50
        }

        $Uri = $Server.BaseUri + "/rest/v1/assets/storages"                  
 
        $Uri += '?'
        $Separator = ''
        if ($fromTime) {
            $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
            $Separator = '&'
        }
        if ($toTime) {
            $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
            $Separator = '&'
        }
        if ($sort) {
            $Uri += "$($Separator)sort=$((Get-Variable 'sort').Value)"
            $Separator = '&'
        }
        if ($limit) {
            $Uri += "$($Separator)limit=$((Get-Variable 'limit').Value)"
            $Separator = '&'
        }
        if ($limit -and $offset) {
            $Uri += "$($Separator)offset=$((Get-Variable 'offset').Value)"
            $Separator = '&'
        }
        if ($expand) {
            $Uri += "$($Separator)expand=$expand"
        }
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }
       
        $Storages = ParseStorages($Result)
        if ($Storages) { Write-Output $Storages }

        if ($FetchAll -and @($Storages).Count -eq $Limit) {
            $Offset += $Limit
            Get-OciStorages -fromTime $fromTime -toTime $toTime -sort $sort -limit $limit -offset $offset -performance:$performance -performancehistory:$performancehistory -storageNodes:$storageNodes -storageResources:$storageResources -storagePools:$storagePools -internalVolumes:$internalVolumes -volumes:$volumes -qtrees:$qtrees -shares:$shares -ports:$ports -datasources:$datasources -annotations:$annotations -disks:$disks -protocols:$protocols -applications:$applications -Server $Server
        }
    }
}

<#
    .SYNOPSIS
    Retrieve total count of storages.
    .DESCRIPTION
    

#>
function Global:Get-OciStorageCount {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                   Position=0,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/count"
 
            try {
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER performance
    Return related Performance
    .PARAMETER protocols
    Return list of related Protocols
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Protocols")][Switch]$protocols,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=19,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storageNodes","storageResources","storagePools","internalVolumes","volumes","qtrees","shares","ports","datasources","annotations","disks","performance","protocols","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciAnnotationsByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations for object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
#>
function Global:Get-OciAnnotationsByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciAnnotationsByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk un-assign applications from asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciUnAssignApplicationsFromAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: "
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the applications of object
    .DESCRIPTION
    
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Get-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk assign applications to asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciAssignApplicationsToAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Add applications for object
    .DESCRIPTION
    Request body should contain only one valid application id, example: <br/>

<pre>
{
    "id":"12345"
}
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Update-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve datasources of a storage.
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve datasources for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
#>
function Global:Get-OciDatasourcesByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve datasources for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve disks for one storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve disks for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performance
    Return related Performance
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER backendVolumes
    Return list of related Backend volumes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciDisksByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve disks for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Backend volumes")][Switch]$backendVolumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","storagePools","performance","storageResources","backendVolumes","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/disks"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve internal volumes for one storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve internal volumes for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePool
    Return related Storage pool
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciInternalVolumesByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve internal volumes for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return related Storage pool")][Switch]$storagePool,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=21,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePool","volumes","storageNodes","annotations","datasources","replicaSources","qtrees","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/internalVolumes"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
      
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one storage performance
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER history
    Return list of related History
#>
function Global:Get-OciStoragePerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/performance"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage ports for one storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve storage ports for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER device
    Return related Device Object
    .PARAMETER fabrics
    Return list of related Fabrics
    .PARAMETER performance
    Return related Performance
    .PARAMETER connectedPorts
    Return list of related Connected ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciPortsByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve storage ports for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Device Object")][Switch]$device,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Fabrics")][Switch]$fabrics,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Connected ports")][Switch]$connectedPorts,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("device","fabrics","performance","connectedPorts","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/ports"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve protocols of a storage.
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve protocols for.
#>
function Global:Get-OciProtocolsByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve protocols for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@()
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/protocols"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage qtrees for one storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve storage qtrees for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER volumes
    Return list of related Volumes
#>
function Global:Get-OciQtreesByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve storage qtrees for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                   Position=10,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","internalVolume","shares","annotations","applications","volumes")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/qtrees"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage shares for one storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve storage shares for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER qtree
    Return related Qtree
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER applications
    Return list of related Applications
#>
function Global:Get-OciSharesByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve storage shares for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Qtree")][Switch]$qtree,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                   Position=8,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","qtree","annotations","applications")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/shares"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage nodes for one storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve storage nodes for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER partner
    Return related HA partner
    .PARAMETER performance
    Return related Performance
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageNodesByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve storage nodes for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related HA partner")][Switch]$partner,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","partner","performance","datasources","storagePools","ports","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/storageNodes"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage pools for one storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve storage pools for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStoragePoolsByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve storage pools for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=14,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","storageResources","internalVolumes","volumes","disks","datasources","storageNodes","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/storagePools"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage resources for one storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve storage resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageResourcesByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve storage resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/storageResources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve volumes for one storage
    .DESCRIPTION
    
    .PARAMETER id
    Id of storage to retrieve volumes for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER virtualStoragePools
    Return list of related Virtual storage pools
    .PARAMETER virtualizer
    Return related Virtualizer
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER autoTierPolicy
    Return related Auto tier policy
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER qtree
    Return related Qtree
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVolumesByStorage {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of storage to retrieve volumes for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Virtual storage pools")][Switch]$virtualStoragePools,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Virtualizer")][Switch]$virtualizer,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Auto tier policy")][Switch]$autoTierPolicy,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=19,
                    HelpMessage="Return related Qtree")][Switch]$qtree,
        [parameter(Mandatory=$False,
                    Position=20,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","virtualStoragePools","virtualizer","internalVolume","autoTierPolicy","ports","storageNodes","replicaSources","datasources","annotations","qtree","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/storages/$id/volumes"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all Switches
    .DESCRIPTION
    Retrieve all Switches
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER limit
    Number of switches per page.
    .PARAMETER offset
    Offset to be used with limit
    .PARAMETER fabric
    Return related Fabric
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciSwitches {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                    Position=0,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Number of switches per page (range: 0-50, default: 0)")][Long]$limit=0,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Offset to be used with limit")][Long]$offset=0,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return related Fabric")][Switch]$fabric,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("fabric","performance","ports","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            # OCI allows to only fetch maximum 50 items, thus we need to repeat the command if no limit is specified to fetch all items
            if ($Limit -eq 0) {
                $FetchAll = $true
                $Limit = 50
            }

            $Uri = $Server.BaseUri + "/rest/v1/assets/switches"            
 
            $Uri += '?'
            $Separator = ''
            if ($fromTime) {
                $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($toTime) {
                $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($sort) {
                $Uri += "$($Separator)sort=$((Get-Variable 'sort').Value)"
                $Separator = '&'
            }
            if ($limit) {
                $Uri += "$($Separator)limit=$((Get-Variable 'limit').Value)"
                $Separator = '&'
            }
            if ($limit -and $offset) {
                $Uri += "$($Separator)offset=$((Get-Variable 'offset').Value)"
                $Separator = '&'
            }
            if ($expand) {
                $Uri += "$($Separator)expand=$expand"
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Switches = ParseSwitches($Result)
            if ($Switches) { Write-Output $Switches }

            if ($FetchAll -and @($Switches).Count -eq $Limit) {
                $Offset += $Limit
                Get-OciSwitches -fromTime $fromTime -toTime $toTime -performance:$performance -performancehistory:$performancehistory -limit $limit -offset $offset -fabric:$fabric -ports:$ports -annotations:$annotations -datasources:$datasources -applications:$appliactions -Server $Server
            }
        }
    }
}

<#
    .SYNOPSIS
    Retrieve total count of switches.
    .DESCRIPTION
    

#>
function Global:Get-OciSwitchCount {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/switches/count"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }

        Write-Output $Result.Value
    }
}

<#
    .SYNOPSIS
    Retrieve one switch
    .DESCRIPTION
    Retrieve one switch
    .PARAMETER id
    Id of switch to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER fabric
    Return related Fabric
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciSwitch {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of switch to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Fabric")][Switch]$fabric,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("fabric","performance","ports","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Switch = ParseSwitches($Result)
            Write-Output $Switch
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciAnnotationsBySwitch {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations for object
    .DESCRIPTION
    Retrieve annotations for object
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
#>
function Global:Get-OciAnnotationsBySwitch {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciAnnotationsBySwitch {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                    Write-Verbose "Body: $Body"
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk un-assign applications from asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciUnAssignApplicationsFromAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: "
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the applications of object
    .DESCRIPTION
    Retrieve the applications of object
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Get-OciApplicationsBySwitch {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk assign applications to asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciAssignApplicationsToAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Add applications for object
    .DESCRIPTION
    Request body should contain only one valid application id, example: <br/>

<pre>
{
    "id":"12345"
}
</pre>
            
    .PARAMETER id
    Id of object to update
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Update-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve datasources of a switch
    .DESCRIPTION
    Retrieve datasources of a switch
    .PARAMETER id
    Id of switch to retrieve datasources for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
#>
function Global:Get-OciDatasourcesBySwitch {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of switch to retrieve datasources for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Datasources = ParseDatasources($Result)
            Write-Output $Datasources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one fabric from switch
    .DESCRIPTION
    
    .PARAMETER id
    Id of switch.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=portSummary)
        .PARAMETER switches
        Return list of related Switches
        .PARAMETER datasources
        Return list of related Datasources
#>
function Global:Get-OciFabricBySwitch {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of switch.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=portSummary)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Switches")][Switch]$switches,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("switches","datasources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/fabric"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one switch performance.
    .DESCRIPTION
    
    .PARAMETER id
    Id of switch.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=portSummary)
    .PARAMETER history
    Return list of related History
#>
function Global:Get-OciSwitchPerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of switch.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=portSummary)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/performance"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve switch ports for one switch
    .DESCRIPTION
    
    .PARAMETER id
    Id of switch to retrieve switch ports for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER device
    Return related Device Object
    .PARAMETER fabrics
    Return list of related Fabrics
    .PARAMETER performance
    Return related Performance
    .PARAMETER connectedPorts
    Return list of related Connected ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciPortsBySwitch {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of switch to retrieve switch ports for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Device Object")][Switch]$device,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Fabrics")][Switch]$fabrics,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Connected ports")][Switch]$connectedPorts,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("device","fabrics","performance","connectedPorts","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/switches/$id/ports"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all Virtual Machines
    .DESCRIPTION
    Retrieve all Virtual Machines
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER performancehistory
    Return related Performance History
    .PARAMETER limit
    Number of virtual machines per page (range: 0-50, default: 0)
    .PARAMETER offset
    Offset to be used with limit
    .PARAMETER sort
    Performance metric for sorting (Default diskIops.total)
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER dataStore
    Return related Datastore
    .PARAMETER host
    Return related Host
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
#>
function Global:Get-OciVirtualMachines {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                    Position=0,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Number of virtual machines per page (range: 0-50, default: 0)")][Long]$limit=0,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Offset to be used with limit")][Long]$offset=0,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Performance metric for sorting (Default diskIops.total)")][String]$sort="diskIops.total",
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Datastore")][Switch]$dataStore,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return related Host")][Switch]$HostSwitch,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                   Position=17,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","dataStore","HostSwitch","vmdks","applications","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            # OCI allows to only fetch maximum 50 items, thus we need to repeat the command if no limit is specified to fetch all items
            if ($Limit -eq 0) {
                $FetchAll = $true
                $Limit = 50
            }

            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines"            
 
            $Uri += '?'
            $Separator = ''
            if ($fromTime) {
                $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($toTime) {
                $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                $Separator = '&'
            }
            if ($sort) {
                $Uri += "$($Separator)sort=$((Get-Variable 'sort').Value)"
                $Separator = '&'
            }
            if ($limit) {
                $Uri += "$($Separator)limit=$((Get-Variable 'limit').Value)"
                $Separator = '&'
            }
            if ($limit -and $offset) {
                $Uri += "$($Separator)offset=$((Get-Variable 'offset').Value)"
                $Separator = '&'
            }
            if ($expand) {
                $Uri += "$($Separator)expand=$expand"
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $VirtualMachines = ParseVirtualMachines($Result)
            Write-Output $VirtualMachines

            if ($FetchAll -and @($VirtualMachines).Count -eq $Limit) {
                $Offset += $Limit
                Get-OciVirtualMachines -fromTime $fromTime -toTime $toTime -performance:$performance -performancehistory:$performancehistory -sort $sort -limit $limit -offset $offset -ports:$ports -storageResources:$storageResources -fileSystems:$fileSystems -dataStore:$dataStore -host:$HostSwitch -vmdks:$vmdks -applications:$applications -annotations:$annotations -datasources:$datasources -Server $Server
            }
        }
    }
}

<#
    .SYNOPSIS
    Retrieve total count of Virtual Machines
    .DESCRIPTION
    Retrieve total count of Virtual Machines
#>
function Global:Get-OciVirtualMachineCount {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                   Position=0,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/count"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }
           
        Write-Output $Result.Value
    }
}

<#
    .SYNOPSIS
    Retrieve one Virtual Machine
    .DESCRIPTION
    Retrieve one Virtual Machine
    .PARAMETER id
    Id of virtual machine to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER dataStore
    Return related Datastore
    .PARAMETER host
    Return related Host
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Datastore")][Switch]$dataStore,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return related Host")][Switch]$host,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=15,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","dataStore","host","vmdks","applications","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $VirtualMachine = ParseVirtualMachines($Result)
            Write-Output $VirtualMachine
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciAnnotationsByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations for object
    .DESCRIPTION
    Retrieve annotations for object
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
#>
function Global:Get-OciAnnotationsByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciAnnotationsByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk un-assign applications from asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciUnAssignApplicationsFromAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the applications of object
    .DESCRIPTION
    Retrieve the applications of object
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Get-OciApplicationsByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk assign applications to asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Bulk-OciAssignApplicationsToAsset {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Add applications for object
    .DESCRIPTION
    Request body should contain only one valid application id, example: <br/>

<pre>
{
    "id":"12345"
}
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Update-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete application from object
    .DESCRIPTION
    Delete application from object
    .PARAMETER id
    Id of object to delete application from
    .PARAMETER appId
    Id of application to delete from object
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Remove-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete application from",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Id of application to delete from object")][Long]$appId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/applications/$appId"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one data store for virtual machine
    .DESCRIPTION
    Retrieve one data store for virtual machine
    .PARAMETER id
    Id of virtual machine to retrieve data store for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER hosts
    Return list of related Hosts
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciDataStoreByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine to retrieve data store for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Hosts")][Switch]$hosts,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","hosts","vmdks","datasources","storageResources","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/dataStore"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Datastore = ParseDatastores($Result)
            Write-Output $Datastore
        }
    }
}

<#
    .SYNOPSIS
    Retrieve datasources of a virtual machine.
    .DESCRIPTION
    Retrieve datasources of a virtual machine.
    .PARAMETER id
    Id of virtual machine to retrieve datasources for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
#>
function Global:Get-OciDatasourcesByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine to retrieve datasources for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Datasources = ParseDatasources($Result)
            Write-Output $Datasources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all file systems by virtual machine
    .DESCRIPTION
    Retrieve all file systems by virtual machine
    .PARAMETER id
    Id of virtual machine to retrieve file systems for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER computeResource
    Return related Compute resource
#>
function Global:Get-OciFileSystemsByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine to retrieve file systems for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Compute resource")][Switch]$computeResource,
        [parameter(Mandatory=$False,
                   Position=7,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storageResources","vmdks","computeResource")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/fileSystems"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one virtual machine host
    .DESCRIPTION
    Retrieve one virtual machine host
    .PARAMETER id
    Id of virtual machine to retrieve host for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER virtualMachines
    Return list of related Virtual machines
    .PARAMETER dataCenter
    Return related Data center
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER clusterHosts
    Return list of related Cluster hosts
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciHostByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine to retrieve host for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Virtual machines")][Switch]$virtualMachines,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Data center")][Switch]$dataCenter,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Cluster hosts")][Switch]$clusterHosts,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=15,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","applications","virtualMachines","dataCenter","annotations","clusterHosts","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/host"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Hosts = ParseHosts($Result)
            Write-Output $Hosts
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one Virtual Machine Performance
    .DESCRIPTION
    Retrieve one Virtual Machine Performance
    .PARAMETER id
    Id of virtual machine to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
        .PARAMETER history
        Return list of related History
#>
function Global:Get-OciVirtualMachinePerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/performance"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all ports by virtual machine
    .DESCRIPTION
    Retrieve all ports by virtual machine
    .PARAMETER id
    Id of virtual machine to retrieve ports for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER device
    Return related Device Object
    .PARAMETER fabrics
    Return list of related Fabrics
    .PARAMETER performance
    Return related Performance
    .PARAMETER connectedPorts
    Return list of related Connected ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciPortsByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine to retrieve ports for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Device Object")][Switch]$device,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Fabrics")][Switch]$fabrics,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Connected ports")][Switch]$connectedPorts,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("device","fabrics","performance","connectedPorts","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/ports"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Ports = ParsePorts($Result)
            Write-Output $Ports
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all storage resources by virtual machine
    .DESCRIPTION
    Retrieve all storage resources by virtual machine
    .PARAMETER id
    Id of virtual machine to retrieve storage resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageResourcesByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine to retrieve storage resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/storageResources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $StorageResources = ParseStorageResources($Result)
            Write-Output $StorageResources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve Vmdks for virtual machine
    .DESCRIPTION
    Retrieve Vmdks for virtual machine
    .PARAMETER id
    Id of virtual machine to retrieve disks for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStore
    Return related Datastore
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER virtualMachine
    Return related Virtual machine
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVmdksByVirtualMachine {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine to retrieve disks for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Datastore")][Switch]$dataStore,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return related Virtual machine")][Switch]$virtualMachine,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","dataStore","storageResources","virtualMachine","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/virtualMachines/$id/vmdks"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Vmdks = ParseVmdks($Result)
            Write-Output $Vmdks
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one virtual machine Vmdk
    .DESCRIPTION
    Retrieve one virtual machine Vmdk
    .PARAMETER id
    Id of virtual machine disk to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStore
    Return related Datastore
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER virtualMachine
    Return related Virtual machine
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVmdk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine disk to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Datastore")][Switch]$dataStore,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return related Virtual machine")][Switch]$virtualMachine,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","dataStore","storageResources","virtualMachine","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/vmdks/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Vmdk = ParseVmdks($Result)
            Write-Output $Vmdk
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciAnnotationsByVmdk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/vmdks/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations for object
    .DESCRIPTION
    Retrieve annotations for object
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
#>
function Global:Get-OciAnnotationsByVmdk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/vmdks/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciAnnotationsByVmdk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/vmdks/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: "
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve datasources of a vmdk.
    .DESCRIPTION
    Retrieve datasources of a vmdk.
    .PARAMETER id
    Id of vmdk to retrieve datasources for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
#>
function Global:Get-OciDatasourcesByVmdk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of vmdk to retrieve datasources for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/vmdks/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            $Datasources = ParseDatasources($Result)
            Write-Output $Datasources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one Vmdk performance
    .DESCRIPTION
    Retrieve one Vmdk performance
    .PARAMETER id
    Id of virtual machine disk to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER history
    Return list of related History
#>
function Global:Get-OciVmdkPerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine disk to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/vmdks/$id/performance"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage resources for virtual machine disk
    .DESCRIPTION
    Retrieve storage resources for virtual machine disk
    .PARAMETER id
    Id of virtual machine disk to retrieve storage resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageResourcesByVmdk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine disk to retrieve storage resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/vmdks/$id/storageResources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $StorageResources = ParseStorageResources($Result)
            Write-Output $StorageResources
        }
    }
}

<#
    .SYNOPSIS
    Retrieve virtual machine for virtual machine disk
    .DESCRIPTION
    Retrieve virtual machine for virtual machine disk
    .PARAMETER id
    Id of virtual machine disk to retrieve virtual machine for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER dataStore
    Return related Datastore
    .PARAMETER host
    Return related Host
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVirtualMachineByVmdk {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of virtual machine disk to retrieve virtual machine for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Datastore")][Switch]$dataStore,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return related Host")][Switch]$host,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=15,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","dataStore","host","vmdks","applications","annotations","datasources","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/vmdks/$id/virtualMachine"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $VirtualMachine = ParseVirtualMachines($Result)
            Write-Output $VirtualMachine
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one volume
    .DESCRIPTION
    Retrieve one volume
    .PARAMETER id
    Id of volume to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER virtualStoragePools
    Return list of related Virtual storage pools
    .PARAMETER virtualizer
    Return related Virtualizer
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER autoTierPolicy
    Return related Auto tier policy
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER qtree
    Return related Qtree
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Virtual storage pools")][Switch]$virtualStoragePools,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Virtualizer")][Switch]$virtualizer,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Auto tier policy")][Switch]$autoTierPolicy,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=19,
                    HelpMessage="Return related Qtree")][Switch]$qtree,
        [parameter(Mandatory=$False,
                    Position=20,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=9,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","virtualStoragePools","virtualizer","internalVolume","autoTierPolicy","ports","storageNodes","replicaSources","datasources","annotations","qtree","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Volume = ParseVolumes($Result)
            Write-Output $Volume
        }
    }
}

<#
    .SYNOPSIS
    Delete annotations from object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
{
  "definition":{"id":"5001"}
},
{
  "definition":{"id":"5002"}
}
]
</pre>
                    
    .PARAMETER id
    Id of object to delete
        .PARAMETER definition
        Return related Definition
#>
function Global:Remove-OciAnnotationsByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve annotations by volume
    .DESCRIPTION
    Retrieve annotations by volume
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=definition)
    .PARAMETER definition
    Return related Definition
#>
function Global:Get-OciAnnotationsByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=definition)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=3,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Update annotations for object
    .DESCRIPTION
    Request body should be like JSON below: <br/>

<pre>

[
  {
    "rawValue": "Bronze",
    "definition": {
      "id": "4992",
    }
  }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER definition
        Return related Definition
#>
function Global:Update-OciAnnotationsByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Return related Definition")][Switch]$definition,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("definition")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/annotations"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ""
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PUT -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PUT to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk un-assign applications from asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Remove-OciApplicationsFromVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="List of application IDs",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$applicationId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ConvertTo-Json @($applicationId | % { @{id=$_} }) -Compress
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the applications of object
    .DESCRIPTION
    Retrieve the applications of object
    .PARAMETER id
    Id of object to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Get-OciApplicationsByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=6,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Bulk assign applications to asset
    .DESCRIPTION
    Request body should contain a list of valid application ids, example: <br/>

<pre>
[
    {
        "id":"12345"
    },
    {
        "id":"67890"
    }
]
</pre>
            
    .PARAMETER id
    Id of object to update
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Add-OciApplicationsToVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="List of application IDs",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][String[]]$applicationId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/applications"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Body = ConvertTo-Json @($applicationId | % { @{id=$_} }) -Compress
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method PATCH -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "PATCH to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Add applications for object
    .DESCRIPTION
    Request body should contain only one valid application id, example: <br/>

<pre>
{
    "id":"12345"
}
</pre>
            
    .PARAMETER id
    Id of object to update
    .PARAMETER applicationId
    Valid application id which should be associated
        .PARAMETER computeResources
        Return list of related Compute resources
        .PARAMETER storageResources
        Return list of related Storage resources
#>
function Global:Update-OciApplicationsByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to update",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Valid application id which should be associated")][String]$applicationId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/applications"                      
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {                
                $Body = ConvertTo-Json ($applicationId | % { @{id=$_} }) -Compress
                Write-Verbose "Body: $Body"
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method POST -Uri $Uri -Headers $Server.Headers -Body $Body -ContentType 'application/json'
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "POST to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Delete application from object
    .DESCRIPTION
    Delete application from object
    .PARAMETER id
    Id of object to delete application from
    .PARAMETER appId
    Id of application to delete from object
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER storageResources
    Return list of related Storage resources
#>
function Global:Remove-OciByTypeAndId {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of object to delete application from",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$True,
                    Position=1,
                    HelpMessage="Id of application to delete from object")][Long]$appId,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                   Position=4,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("computeResources","storageResources")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/applications/$appId"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method DELETE -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "DELETE to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the auto tier policy name of a volume.
    .DESCRIPTION
    Retrieve the auto tier policy name of a volume.
    .PARAMETER id
    Id of the volume to retrieve the auto tier policy name.
#>
function Global:Get-OciAutoTierPolicyByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of the volume to retrieve the auto tier policy name.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@()
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/autoTierPolicy"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all compute resources for a volume
    .DESCRIPTION
    Retrieve all compute resources for a volume
    .PARAMETER id
    Id of volume to retrieve compute resources for
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER fileSystems
    Return list of related File systems
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciComputeResourcesByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve compute resources for",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related File systems")][Switch]$fileSystems,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=9,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","ports","storageResources","fileSystems","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/computeResources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all data stores for a given target volume.
    .DESCRIPTION
    Retrieve all data stores for a given target volume.
    .PARAMETER id
    Id of target volume to retrieve the data stores for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER performance
    Return related Performance
    .PARAMETER hosts
    Return list of related Hosts
    .PARAMETER vmdks
    Return list of related Vmdks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciDatastoresByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of target volume to retrieve the data stores for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Hosts")][Switch]$hosts,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Vmdks")][Switch]$vmdks,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=11,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("performance","hosts","vmdks","datasources","storageResources","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/dataStores"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
           
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve datasources of a volume.
    .DESCRIPTION
    Retrieve datasources of a volume.
    .PARAMETER id
    Id of volume to retrieve datasources for.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER acquisitionUnit
    Return related Acquisition unit
    .PARAMETER note
    Return related Note
    .PARAMETER changes
    Return list of related Changes
    .PARAMETER packages
    Return list of related Packages
    .PARAMETER activePatch
    Return related Active patch
    .PARAMETER events
    Return list of related Events
    .PARAMETER devices
    Return list of related Devices
    .PARAMETER config
    Return related Config
#>
function Global:Get-OciDatasourcesByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve datasources for.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Acquisition unit")][Switch]$acquisitionUnit,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Note")][Switch]$note,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Changes")][Switch]$changes,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Packages")][Switch]$packages,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return related Active patch")][Switch]$activePatch,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Events")][Switch]$events,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Devices")][Switch]$devices,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Config")][Switch]$config,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("acquisitionUnit","note","changes","packages","activePatch","events","devices","config")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/datasources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve internal volume for a given volume.
    .DESCRIPTION
    Retrieve internal volume for a given volume.
    .PARAMETER id
    Id of volume to retrieve the internal volume.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePool
    Return related Storage pool
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciInternalVolumeByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve the internal volume.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return related Storage pool")][Switch]$storagePool,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=17,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePool","volumes","storageNodes","annotations","datasources","replicaSources","qtrees","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/internalVolume"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve one volume performance
    .DESCRIPTION
    
    .PARAMETER id
    Id of volume to retrieve
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER history
    Return list of related History
#>
function Global:Get-OciVolumePerformance {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related History")][Switch]$history,
        [parameter(Mandatory=$False,
                   Position=5,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("history")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/performance"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            $Performance = ParsePerformance($Result)
            Write-Output $Performance
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all storage ports and their connected ports by volume.
    .DESCRIPTION
    
    .PARAMETER id
    Id of volume to retrieve the ports that are connected to storage ports.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER device
    Return related Device Object
    .PARAMETER fabrics
    Return list of related Fabrics
    .PARAMETER performance
    Return related Performance
    .PARAMETER connectedPorts
    Return list of related Connected ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciPortsByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve the ports that are connected to storage ports.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Device Object")][Switch]$device,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Fabrics")][Switch]$fabrics,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Connected ports")][Switch]$connectedPorts,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("device","fabrics","performance","connectedPorts","annotations","datasources","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/ports"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve qtree for a given volume.
    .DESCRIPTION
    
    .PARAMETER id
    Id of volume to retrieve the qtree.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER volumes
    Return list of related Volumes
#>
function Global:Get-OciQtree {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve the qtree.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                   Position=10,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","internalVolume","shares","annotations","applications","volumes")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/qtree"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve all source volumes for a given target volume.
    .DESCRIPTION
    
    .PARAMETER id
    Id of target volume to retrieve the source volumes.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER dataStores
    Return list of related Datastores
    .PARAMETER computeResources
    Return list of related Compute resources
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER virtualStoragePools
    Return list of related Virtual storage pools
    .PARAMETER virtualizer
    Return related Virtualizer
    .PARAMETER internalVolume
    Return related Internal volume
    .PARAMETER autoTierPolicy
    Return related Auto tier policy
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER replicaSources
    Return list of related Replica sources
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER qtree
    Return related Qtree
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciSourceVolumesByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of target volume to retrieve the source volumes.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Datastores")][Switch]$dataStores,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Compute resources")][Switch]$computeResources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Virtual storage pools")][Switch]$virtualStoragePools,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Virtualizer")][Switch]$virtualizer,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return related Internal volume")][Switch]$internalVolume,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Auto tier policy")][Switch]$autoTierPolicy,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Replica sources")][Switch]$replicaSources,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=19,
                    HelpMessage="Return related Qtree")][Switch]$qtree,
        [parameter(Mandatory=$False,
                    Position=20,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=21,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","dataStores","computeResources","applications","storagePools","virtualStoragePools","virtualizer","internalVolume","autoTierPolicy","ports","storageNodes","replicaSources","datasources","annotations","qtree","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/replicaSources"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve the storage of a volume.
    .DESCRIPTION
    
    .PARAMETER id
    Id of the volume to retrieve the storage.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER performance
    Return related Performance
    .PARAMETER protocols
    Return list of related Protocols
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of the volume to retrieve the storage.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Protocols")][Switch]$protocols,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=19,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storageNodes","storageResources","storagePools","internalVolumes","volumes","qtrees","shares","ports","datasources","annotations","disks","performance","protocols","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/storage"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage nodes for a given volume.
    .DESCRIPTION
    
    .PARAMETER id
    Id of volume to retrieve the storage nodes.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER partner
    Return related HA partner
    .PARAMETER performance
    Return related Performance
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStorageNodesByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve the storage nodes.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related HA partner")][Switch]$partner,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=12,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","partner","performance","datasources","storagePools","ports","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/storageNodes"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve storage pools for a given volume.
    .DESCRIPTION
    
    .PARAMETER id
    Id of volume to retrieve the storage pools.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciStoragePoolsByVolume {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve the storage pools.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=14,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","storageResources","internalVolumes","volumes","disks","datasources","storageNodes","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/storagePools"
            
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve virtual storage pools for a given volume.
    .DESCRIPTION
    
    .PARAMETER id
    Id of volume to retrieve the virtual storage pools.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storage
    Return related Storage
    .PARAMETER performance
    Return related Performance
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVirtualStoragePools {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve the virtual storage pools.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return related Storage")][Switch]$storage,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=14,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storage","performance","storageResources","internalVolumes","volumes","disks","datasources","storageNodes","annotations","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/virtualStoragePools"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Retrieve virtualizer for a given backend volume.
    .DESCRIPTION
    
    .PARAMETER id
    Id of volume to retrieve the virtualizer.
    .PARAMETER fromTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER toTime
    Filter for time range, either in milliseconds or as DateTime
    .PARAMETER expand
    Expand parameter for underlying JSON object (e.g. expand=read,items)
    .PARAMETER storageNodes
    Return list of related Storage nodes
    .PARAMETER storageResources
    Return list of related Storage resources
    .PARAMETER storagePools
    Return list of related Storage pools
    .PARAMETER internalVolumes
    Return list of related Internal volumes
    .PARAMETER volumes
    Return list of related Volumes
    .PARAMETER qtrees
    Return list of related Qtrees
    .PARAMETER shares
    Return list of related Shares
    .PARAMETER ports
    Return list of related Ports
    .PARAMETER datasources
    Return list of related Datasources
    .PARAMETER annotations
    Return list of related Annotations
    .PARAMETER disks
    Return list of related Disks
    .PARAMETER performance
    Return related Performance
    .PARAMETER protocols
    Return list of related Protocols
    .PARAMETER applications
    Return list of related Applications
    .PARAMETER performancehistory
    Return related Performance History
#>
function Global:Get-OciVirtualizer {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                    Position=0,
                    HelpMessage="Id of volume to retrieve the virtualizer.",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][Long[]]$id,
        [parameter(Mandatory=$False,
                    Position=1,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$fromTime,
        [parameter(Mandatory=$False,
                    Position=2,
                    HelpMessage="Filter for time range, either in milliseconds or as DateTime")][PSObject]$toTime,
        [parameter(Mandatory=$False,
                    Position=3,
                    HelpMessage="Expand parameter for underlying JSON object (e.g. expand=read,items)")][String]$expand,
        [parameter(Mandatory=$False,
                    Position=4,
                    HelpMessage="Return list of related Storage nodes")][Switch]$storageNodes,
        [parameter(Mandatory=$False,
                    Position=5,
                    HelpMessage="Return list of related Storage resources")][Switch]$storageResources,
        [parameter(Mandatory=$False,
                    Position=6,
                    HelpMessage="Return list of related Storage pools")][Switch]$storagePools,
        [parameter(Mandatory=$False,
                    Position=7,
                    HelpMessage="Return list of related Internal volumes")][Switch]$internalVolumes,
        [parameter(Mandatory=$False,
                    Position=8,
                    HelpMessage="Return list of related Volumes")][Switch]$volumes,
        [parameter(Mandatory=$False,
                    Position=9,
                    HelpMessage="Return list of related Qtrees")][Switch]$qtrees,
        [parameter(Mandatory=$False,
                    Position=10,
                    HelpMessage="Return list of related Shares")][Switch]$shares,
        [parameter(Mandatory=$False,
                    Position=11,
                    HelpMessage="Return list of related Ports")][Switch]$ports,
        [parameter(Mandatory=$False,
                    Position=12,
                    HelpMessage="Return list of related Datasources")][Switch]$datasources,
        [parameter(Mandatory=$False,
                    Position=13,
                    HelpMessage="Return list of related Annotations")][Switch]$annotations,
        [parameter(Mandatory=$False,
                    Position=14,
                    HelpMessage="Return list of related Disks")][Switch]$disks,
        [parameter(Mandatory=$False,
                    Position=15,
                    HelpMessage="Return related Performance")][Switch]$performance,
        [parameter(Mandatory=$False,
                    Position=16,
                    HelpMessage="Return list of related Protocols")][Switch]$protocols,
        [parameter(Mandatory=$False,
                    Position=17,
                    HelpMessage="Return list of related Applications")][Switch]$applications,
        [parameter(Mandatory=$False,
                    Position=18,
                    HelpMessage="Return related Performance History")][Switch]$performancehistory,
        [parameter(Mandatory=$False,
                   Position=19,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }

        $switchparameters=@("storageNodes","storageResources","storagePools","internalVolumes","volumes","qtrees","shares","ports","datasources","annotations","disks","performance","protocols","applications","performancehistory")
        foreach ($parameter in $switchparameters) {
            if ((Get-Variable $parameter).Value) {
                if ($expand) {
                    $expand += ",$($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')"
                }
                else {
                    $expand = $($parameter -replace 'performancehistory','performance.history' -replace 'hostswitch','host')
                }
            }
        }
    }
   
    Process {
        $id = @($id)
        foreach ($id in $id) {
            $Uri = $Server.BaseUri + "/rest/v1/assets/volumes/$id/virtualizer"            
 
            if ($fromTime -or $toTime -or $expand) {
                $Uri += '?'
                $Separator = ''
                if ($fromTime) {
                    $Uri += "fromTime=$($fromTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($toTime) {
                    $Uri += "$($Separator)toTime=$($toTime | ConvertTo-UnixTimestamp)"
                    $Separator = '&'
                }
                if ($expand) {
                    $Uri += "$($Separator)expand=$expand"
                }
            }
 
            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }

            Write-Output $Result
        }
    }
}

<#
    .SYNOPSIS
    Search for OCI Objects
    .DESCRIPTION
    Search for OCI Objects
    .PARAMETER query
    Query parameter
#>
function Global:Search-Oci {
    [CmdletBinding()]
 
    PARAM (
            [parameter(Mandatory=$true,
                    Position=0,
                    HelpMessage="The search query expression parameter",
                    ValueFromPipeline=$True,
                    ValueFromPipelineByPropertyName=$True)][string[]]$query,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }

    Process {
        foreach ($query in $query) {
            $Uri = $Server.BaseUri + "/rest/v1/search?query=$query"

            try {
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            }
            catch {
                $ResponseBody = ParseExceptionBody $_.Exception.Response
                Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
            }
 
            if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
                $Result = ParseJsonString($Result.Trim())
            }
       
            Write-Output $Result.resultsByCategory
        }
    }
}
<#
    .SYNOPSIS
    Retrieve OCI Server health status
    .DESCRIPTION
    Retrieve OCI Server health status
#>
function Global:Get-OciHealth {
    [CmdletBinding()]

    PARAM (
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/admin/health"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
 
        if (([String]$Result).Trim().startsWith('{') -or ([String]$Result).toString().Trim().startsWith('[')) {
            $Result = ParseJsonString($Result.Trim())
        }

        foreach ($Item in $Result) {
            $Item.time = $Item.time | ConvertFrom-UnixTimestamp
        }
       
        Write-Output $Result
    }
}

<#
    .SYNOPSIS
    Restore OCI Backup
    .DESCRIPTION
    Restore OCI Backup
#>
function Global:Restore-OciBackup {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                   Position=0,
                   HelpMessage="Full path of OnCommand Insight Backup, either locally or on OnCommand Insight Server.",
                   ValueFromPipeline=$True,
                   ValueFromPipelineByPropertyName=$True)][PSObject[]]$FilePath,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $FilePath = @($FilePath)

        $StartTime = Get-Date

        foreach ($FilePath in $FilePath) {
            $Uri = $Server.BaseUri + "/rest/v1/admin/restore"

            if (Test-Path $FilePath) {
                Write-Host "Found local OCI Backup in $FilePath which will be restored"
                
                Write-Host "Starting Restore job. This can take several hours..."

                $Job = Start-Job {
                    Import-Module OnCommand-Insight

                    [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy

                    Invoke-MultipartFormDataUpload -InFile $args[0] -Uri $args[1] -Header $args[2]
                } -ArgumentList $FilePath,$URI,$Server.Headers
                
            }
            else {
                Write-Host "No local Backup in $FilePath, trying to restore backup residing on OnCommand Insight Server"
            
                # create boundary
                $boundary = [System.Guid]::NewGuid().ToString()
        
                # Linefeed character
                $LF = "`r`n"

                # Build Body for  form-data manually since PS does not support multipart/form-data out of the box
                $Body = (
                    "--$boundary",
                    "Content-Disposition: form-data; name=`"backupFilePath`"$LF",
                    $FilePath,
                    "--$boundary--$LF"
                ) -join $LF

                Write-Host "Starting Restore job..."

                $Job = Start-Job {

                    Import-Module OnCommand-Insight

                    [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy

                    Invoke-RestMethod -Uri $args[0] -Timeout 864000000000 -Method Post -ContentType "multipart/form-data; boundary=`"$($args[1])`"" -Body $args[2] -Headers $args[3]
                } -ArgumentList $URI,$boundary,$Body,$Server.Headers
            }

            $percentComplete = 10
            $activity = "Restore started"
            $status = "Uploading"
            Write-Progress -Activity $activity -status $status -percentComplete $percentComplete
            sleep 2
            $i = 0
            while ($true) {
                $ProgressUri = $Uri + "?_=" + (get-date | ConvertTo-UnixTimestamp)
                $i++
                try {
                    $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $ProgressUri -Headers $Server.Headers -ErrorAction SilentlyContinue
                }
                catch {
                    $ResponseBody = ParseExceptionBody $_.Exception.Response
                    Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
                }
                if ($i -eq 1440) { 
                    Write-Host ''
                    throw 'Backup did not finish within 24 hours' 
                }
                if ($Result.status -eq 'SUCCESSFUL') {
                    Write-Host "finished"
                    return
                }
                elseif ($Result.status -eq 'FAILED' -and ($Result.currentStep.startTime | get-date) -ge $StartTime -or $Job.State -ne 'Running') {
                    return
                }
                elseif (($Result.currentStep.startTime | get-date) -ge $StartTime) {
                    $activity = $Result.currentStep.operationText
                    $status = $Result.components.name | select -last 1
                }
                switch ($Result.currentStep.phaseText) {
                    "Restoring" { $percentComplete = 20 }
                    "Waiting" { $percentComplete = 30 }
                } 
                Write-Progress -Activity $activity -status $status -percentComplete $percentComplete
                sleep 5
            }
            Write-Progress -Activity $Result.currentStep.phaseText -status $Result.currentStep.operationText -percentComplete 100
            sleep 1
        }
        Write-Output $Result
    }
}

<#
    .SYNOPSIS
    Get OCI Backup
    .DESCRIPTION
    Get OCI Backup
#>
function Global:Get-OciBackup {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$True,
                   Position=0,
                   HelpMessage="Path where to store OnCommand Insight Backup.")][PSObject]$Path,
        [parameter(Mandatory=$False,
                   Position=1,
                   HelpMessage="Time in minutes to wait for backup to complete (Default = 60 minutes).")][PSObject]$Timeout=60,
        [parameter(Mandatory=$False,
                   Position=2,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $URI = $Server.BaseUri + "/rest/v1/admin/backups/current"
 
        Write-Host "Starting Backup"  
        $Job = Start-Job { 
            add-type @"
                    using System.Net;
                    using System.Security.Cryptography.X509Certificates;
                    public class TrustAllCertsPolicy : ICertificatePolicy {
                       public bool CheckValidationResult(
                            ServicePoint srvPoint, X509Certificate certificate,
                            WebRequest request, int certificateProblem) {
                            return true;
                        }
                    }
"@

            [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy

            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

            Write-Verbose "Test"
            Write-Verbose $args[0]
            Write-Verbose $args[1]

            Invoke-RestMethod -TimeoutSec ([int32]::MaxValue) -Method POST -Uri $args[0] -Headers $args[1] -Verbose
        } -ArgumentList $URI,$Server.Headers

        try {
            Write-Progress -Activity "Backup started" -status "Backing up" -percentComplete 0
            $i = 0
            while ($true) {
                $i++
                $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
                if ($i -eq ($Timeout * 12) -or $Job.State -ne 'Running') { 
                    Write-Progress -Activity "Backup did not complete in $Timeout minutes" -status "Backing failed" -percentComplete 100
                }
                if ($Result.status -eq 'SUCCESSFUL') { 
                    Write-Progress -Activity $Result -status $Result -percentComplete 100
                    sleep 1
                    break 
                }
                Write-Progress -Activity "Backup started" -status $Result.status -percentComplete (100*$i/($Timeout*12))
                sleep 5
            }
            $Uri = $($Server.BaseUri) + $Result.Url
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }

        $FilePath = $Path + '\' + (($Uri -split '/') | select -last 1)
        Write-Host $FilePath
        $Date = [datetime]::ParseExact($($FilePath -replace '.+_D(.*)_[0-9]+.zip','$1'),"yyyyMMdd_HHmm",$null)

        try {
            Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers -OutFile $FilePath
            Write-Host "Backup Saved to $FilePath"
            
            $Result = New-Object -TypeName PSCustomObject -ArgumentList @{FilePath=$FilePath;Date=$Date;URI=$Uri}

            Write-Output $Result
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
    }
}

<#
    .SYNOPSIS
    Get OCI Backups
    .DESCRIPTION
    Get OCI Backups
#>
function Global:Get-OciBackups {
    [CmdletBinding()]
 
    PARAM (
        [parameter(Mandatory=$False,
                   Position=0,
                   HelpMessage="OnCommand Insight Server.")]$Server=$CurrentOciServer
    )
 
    Begin {
        $Result = $null
        if (!$Server) {
            throw "Server parameter not specified and no global OCI Server available. Run Connect-OciServer first!"
        }
    }
   
    Process {
        $Uri = $Server.BaseUri + "/rest/v1/admin/backups"
 
        try {
            $Result = Invoke-RestMethod -TimeoutSec $Server.Timeout -Method GET -Uri $Uri -Headers $Server.Headers
            
            $Result = $Result | % { [PSCustomObject]@{FilePath=$_.path;Date=($_.date | get-date)} }

            Write-Output $Result
        }
        catch {
            $ResponseBody = ParseExceptionBody $_.Exception.Response
            Write-Error "GET to $Uri failed with Exception $($_.Exception.Message) `n $responseBody"
        }
    }
}